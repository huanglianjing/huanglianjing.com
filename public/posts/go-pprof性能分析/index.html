<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go Pprof性能分析 | My New Hugo Site</title>
<meta name="keywords" content="Go, pprof">
<meta name="description" content="1. 简介 pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。
当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。
pprof 的采集方式分为以下几种：
runtime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。 net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。 go test：通过运行测试用例，并指定所需标识来进行采集。 pprof 可以分析包含以下几种：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。 采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。
2. 使用方式 2.1 net/http/pprof 端口监听 该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。
代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。
package main import ( &#34;log&#34; &#34;net/http&#34; _ &#34;net/http/pprof&#34; &#34;time&#34; ) var datas []string func main() { go func() { _ = http.">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Go Pprof性能分析" />
<meta property="og:description" content="1. 简介 pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。
当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。
pprof 的采集方式分为以下几种：
runtime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。 net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。 go test：通过运行测试用例，并指定所需标识来进行采集。 pprof 可以分析包含以下几种：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。 采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。
2. 使用方式 2.1 net/http/pprof 端口监听 该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。
代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。
package main import ( &#34;log&#34; &#34;net/http&#34; _ &#34;net/http/pprof&#34; &#34;time&#34; ) var datas []string func main() { go func() { _ = http." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-25T01:52:12+08:00" />
<meta property="article:modified_time" content="2023-07-25T01:52:12+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go Pprof性能分析"/>
<meta name="twitter:description" content="1. 简介 pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。
当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。
pprof 的采集方式分为以下几种：
runtime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。 net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。 go test：通过运行测试用例，并指定所需标识来进行采集。 pprof 可以分析包含以下几种：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。 采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。
2. 使用方式 2.1 net/http/pprof 端口监听 该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。
代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。
package main import ( &#34;log&#34; &#34;net/http&#34; _ &#34;net/http/pprof&#34; &#34;time&#34; ) var datas []string func main() { go func() { _ = http."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Go Pprof性能分析",
      "item": "http://example.org/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go Pprof性能分析",
  "name": "Go Pprof性能分析",
  "description": "1. 简介 pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。\n当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。\npprof 的采集方式分为以下几种：\nruntime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。 net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。 go test：通过运行测试用例，并指定所需标识来进行采集。 pprof 可以分析包含以下几种：\nCPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。 采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。\n2. 使用方式 2.1 net/http/pprof 端口监听 该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。\n代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; _ \u0026#34;net/http/pprof\u0026#34; \u0026#34;time\u0026#34; ) var datas []string func main() { go func() { _ = http.",
  "keywords": [
    "Go", "pprof"
  ],
  "articleBody": "1. 简介 pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。\n当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。\npprof 的采集方式分为以下几种：\nruntime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。 net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。 go test：通过运行测试用例，并指定所需标识来进行采集。 pprof 可以分析包含以下几种：\nCPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。 采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。\n2. 使用方式 2.1 net/http/pprof 端口监听 该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。\n代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。\npackage main import ( \"log\" \"net/http\" _ \"net/http/pprof\" \"time\" ) var datas []string func main() { go func() { _ = http.ListenAndServe(\":8080\", nil) }() for { log.Printf(\"len: %d\", add(\"go pprof add text\")) time.Sleep(time.Millisecond * 10) } } func add(str string) int { data := []byte(str) datas = append(datas, string(data)) return len(datas) } 之所以需要对 net/http/pprof 进行空白导入，是因为该包在源代码 pprof.go 中对 /debug/pprof/ 下的几个路径进行了路由注册。\nfunc init() { http.HandleFunc(\"/debug/pprof/\", Index) http.HandleFunc(\"/debug/pprof/cmdline\", Cmdline) http.HandleFunc(\"/debug/pprof/profile\", Profile) http.HandleFunc(\"/debug/pprof/symbol\", Symbol) http.HandleFunc(\"/debug/pprof/trace\", Trace) } 如果所要进行分析的程序是一个 Web 服务，已经开启端口监听，对外提供 HTTP 请求接口服务，则只需要对 net/http/pprof 包进行空白导入，即可通过其他命令进行数据分析。\nimport _ \"net/http/pprof\" 2.1.1 生成报告分析 运行程序，然后在程序运行的期间在浏览器访问网址：http://localhost:8080/debug/pprof/\n打开后可以看到：\n可以看到一些分析指标的数量以及链接，可以点击链接查看详情。这些分析指标对应的含义是：\nallocs：查看过去所有的内存分配信息。 block：查看导致阻塞同步的堆栈跟踪。 cmdline：当前程序的命令行的完整调用路径。 goroutine：查看当前所有运行的 goroutines 堆栈跟踪。 heap：查看活动对象的内存分配情况。 mutex：查看导致互斥锁的竞争持有者的堆栈跟踪。 profile：进行CPU分析，可以通过GET请求参数指定时间范围。 threadcreate：查看创建新操作系统线程的堆栈跟踪。 trace：生成对目前程序执行的分析文件，用于通过 go tool trace 进行分析，可以通过GET请求参数指定时间范围。 以及点击 full goroutine stack dump 将会列出各个协程详细的调用栈信息。\n2.1.2 终端命令行分析 同样要先运行程序，然后在程序运行的期间终端执行命令，命令参数为 go tool pprof 的格式，不同的 url 表示进行不同的分析类型以及指定的参数。\n执行命令时需要程序正在运行状态，以进行信息采集。进入 pprof 的命令行交互后，实际上是将程序当前运行的情况，以 profile 文件保存在目录 ~/pprof/ 中并进行分析了，程序本身中止运行不会对当前执行 pprof 的命令有所影响。\nCPU Profiling\n分析程序的CPU使用情况，在终端执行命令：\n$ go tool pprof http://localhost:8080/debug/pprof/profile Fetching profile over HTTP from http://localhost:8080/debug/pprof/profile Saved profile in /Users/moondo/pprof/pprof.samples.cpu.006.pb.gz Type: cpu Duration: 30.07s, Total samples = 530ms ( 1.76%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 默认为采集30秒数据，所以执行后需要等待30秒后才可以进入命令行交互模式，可以在请求地址设置参数 seconds=60，表示采集60秒或其它时长的数据进行分析。\n查看CPU耗时前10的函数：\n(pprof) top 10 Showing nodes accounting for 530ms, 100% of 530ms total Showing top 10 nodes out of 46 flat flat% sum% cum cum% 190ms 35.85% 35.85% 190ms 35.85% runtime.kevent 110ms 20.75% 56.60% 110ms 20.75% runtime.pthread_cond_wait 70ms 13.21% 69.81% 70ms 13.21% syscall.syscall 50ms 9.43% 79.25% 50ms 9.43% runtime.nanotime1 50ms 9.43% 88.68% 50ms 9.43% runtime.pthread_cond_signal 30ms 5.66% 94.34% 240ms 45.28% runtime.netpoll 20ms 3.77% 98.11% 20ms 3.77% runtime.read 10ms 1.89% 100% 10ms 1.89% runtime.goready 0 0% 100% 70ms 13.21% internal/poll.(*FD).Write 0 0% 100% 70ms 13.21% internal/poll.ignoringEINTRIO (inline) 还有其它很多命令可以执行 help 查看说明。\nHeap Profiling\n分析程序的内存使用情况，在终端执行命令：\n$ go tool pprof http://localhost:8080/debug/pprof/heap Fetching profile over HTTP from http://localhost:8080/debug/pprof/heap Saved profile in /Users/moondo/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz Type: inuse_space Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 该命令无需等待直接进入命令行，且默认分析的是常驻内存的占用，也可以在参数中选择分析常驻内存占用或者临时的内存分配情况。\n# 内存占用 $ go tool pprof -inuse_space http://localhost:8080/debug/pprof/heap Fetching profile over HTTP from http://localhost:8080/debug/pprof/heap Saved profile in /Users/moondo/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.007.pb.gz Type: inuse_space Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top 10 Showing nodes accounting for 5.29MB, 100% of 5.29MB total flat flat% sum% cum cum% 5.29MB 100% 100% 5.29MB 100% main.add (inline) 0 0% 100% 5.29MB 100% main.main.func1 # 内存分配 $ go tool pprof -alloc_objects http://localhost:8080/debug/pprof/heap Fetching profile over HTTP from http://localhost:8080/debug/pprof/heap Saved profile in /Users/moondo/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.006.pb.gz Type: alloc_objects Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top 10 Showing nodes accounting for 196619, 100% of 196675 total Dropped 19 nodes (cum \u003c= 983) flat flat% sum% cum cum% 131083 66.65% 66.65% 131083 66.65% main.add (inline) 32768 16.66% 83.31% 32768 16.66% fmt.Sprintf 32768 16.66% 100% 196619 100% main.main.func1 0 0% 100% 32768 16.66% log.Printf Goroutine Profiling\n分析程序的协程情况，在终端执行命令：\n$ go tool pprof http://localhost:8080/debug/pprof/goroutine Fetching profile over HTTP from http://localhost:8080/debug/pprof/goroutine Saved profile in /Users/moondo/pprof/pprof.goroutine.001.pb.gz Type: goroutine Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 该命令无需等待直接进入命令行。\n使用traces命令打印所有的调用栈：\n(pprof) traces Type: goroutine -----------+------------------------------------------------------- 1 runtime.gopark runtime.netpollblock internal/poll.runtime_pollWait internal/poll.(*pollDesc).wait internal/poll.(*pollDesc).waitRead (inline) internal/poll.(*FD).Accept net.(*netFD).accept net.(*TCPListener).accept net.(*TCPListener).Accept net/http.(*Server).Serve net/http.(*Server).ListenAndServe net/http.ListenAndServe (inline) main.main runtime.main -----------+------------------------------------------------------- 1 runtime.gopark time.Sleep main.main.func1 -----------+------------------------------------------------------- 1 runtime/pprof.runtime_goroutineProfileWithLabels runtime/pprof.writeRuntimeProfile runtime/pprof.writeGoroutine runtime/pprof.(*Profile).WriteTo net/http/pprof.handler.ServeHTTP net/http/pprof.Index net/http.HandlerFunc.ServeHTTP net/http.(*ServeMux).ServeHTTP net/http.serverHandler.ServeHTTP net/http.(*conn).serve -----------+------------------------------------------------------- 1 net/http.(*connReader).backgroundRead -----------+------------------------------------------------------- 调用栈之间用横线分割，每个调用栈从下面的行调用到上面的行。\nMutex Profiling\n互斥锁分析需要在代码中调用 runtime.SetMutexProfileFraction() 并设置参数大于0，以开启互斥锁的采集。\n调整一下示例代码，开启多个协程往一个map中写数据，然后用互斥锁造成锁定的状态。\npackage main import ( \"net/http\" _ \"net/http/pprof\" \"runtime\" \"sync\" ) func init() { runtime.SetMutexProfileFraction(1) } func main() { var m sync.Mutex var datas = make(map[int]struct{}) for i := 0; i \u003c 999; i++ { go func(i int) { m.Lock() defer m.Unlock() datas[i] = struct{}{} }(i) } _ = http.ListenAndServe(\":8080\", nil) } 然后在终端执行命令：\n$ go tool pprof http://localhost:8080/debug/pprof/mutex Fetching profile over HTTP from http://localhost:8080/debug/pprof/mutex Saved profile in /Users/moondo/pprof/pprof.contentions.delay.001.pb.gz Type: delay Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 查看互斥量排名：\n(pprof) top Showing nodes accounting for 1.41ms, 100% of 1.41ms total flat flat% sum% cum cum% 1.41ms 100% 100% 1.41ms 100% sync.(*Mutex).Unlock 0 0% 100% 1.41ms 100% main.main.func1 查看指定函数的代码，可以看到引起互斥锁的函数以及开销：\n(pprof) list main Total: 1.41ms ROUTINE ======================== main.main.func1 in /Users/moondo/go/src/test/cmd/pprof_http_mutex.go 0 1.41ms (flat, cum) 100% of Total . . 17:\tfor i := 0; i \u003c 999; i++ { . . 18:\tgo func(i int) { . . 19:\tm.Lock() . . 20:\tdefer m.Unlock() . . 21:\tdatas[i] = struct{}{} . 1.41ms 22:\t}(i) . . 23:\t} . . 24:\t_ = http.ListenAndServe(\":8080\", nil) . . 25:} Block Profiling\n阻塞分析需要在代码中调用 runtime.SetBlockProfileRate() 并设置参数大于0，以开启阻塞情况的采集。\n与互斥锁分析的代码类似，但初始化的函数换了：\npackage main import ( \"net/http\" _ \"net/http/pprof\" \"runtime\" \"sync\" ) func init() { runtime.SetBlockProfileRate(1) } func main() { var m sync.Mutex var datas = make(map[int]struct{}) for i := 0; i \u003c 999; i++ { go func(i int) { m.Lock() defer m.Unlock() datas[i] = struct{}{} }(i) } _ = http.ListenAndServe(\":8080\", nil) } 然后在终端执行命令：\n$ go tool pprof http://localhost:8080/debug/pprof/block Fetching profile over HTTP from http://localhost:8080/debug/pprof/block Saved profile in /Users/moondo/pprof/pprof.contentions.delay.002.pb.gz Type: delay Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 查看阻塞排名：\n(pprof) top Showing nodes accounting for 133.40ms, 100% of 133.40ms total flat flat% sum% cum cum% 133.40ms 100% 100% 133.40ms 100% sync.(*Mutex).Lock (inline) 0 0% 100% 133.40ms 100% main.main.func1 查看指定函数的代码，可以看到引起阻塞的函数以及开销：\n(pprof) list main Total: 133.40ms ROUTINE ======================== main.main.func1 in /Users/moondo/go/src/test/cmd/pprof_http_block.go 0 133.40ms (flat, cum) 100% of Total . . 14:func main() { . . 15:\tvar m sync.Mutex . . 16:\tvar datas = make(map[int]struct{}) . . 17:\tfor i := 0; i \u003c 999; i++ { . . 18:\tgo func(i int) { . 133.40ms 19:\tm.Lock() . . 20:\tdefer m.Unlock() . . 21:\tdatas[i] = struct{}{} . . 22:\t}(i) . . 23:\t} . . 24:\t_ = http.ListenAndServe(\":8080\", nil) 2.1.3 可视化界面分析 还是使用前面提到的，开启一个协程对一个字符串不断地追加内容的例子。该方式将会打开一个有图形的可视化界面，使分析更加直观优雅。使用该方式需要提前安装一个软件 graphviz。\n执行程序，然后在终端通过 wget 或 curl 导出CPU分析的文件：\nwget http://localhost:8080/debug/pprof/profile curl -o profile http://localhost:8080/debug/pprof/profile 等待30秒后（CPU分析不带参数默认30秒），会在当前目录保存一个 profile 文件。\n然后在终端执行命令，在指定端口号运行一个 pprof 分析网站，这里要换一个端口号，不要和现有程序执行的端口号重复了：\ngo tool pprof -http=:8081 profile 自动打开网站，默认显示的是程序调用的链路以及每个调用的耗时，在菜单选择 VIEW - Graph 也可以显示这个。\n代码中主要做的事情是：开启一个协程，然后在循环中不断地给字符串追加内容、向标准输出输出一行日志，然后睡眠10毫秒。在上图左侧的main函数可以看到，往下的箭头指向了三块，分别对应 add 函数耗时 10ms，log.Printf 函数耗时 200ms，time.Sleep 函数耗时 20ms。由此可以分析得出结论，打印日志到标准输出比其他两项更加耗时。\n在菜单选择 VIEW - Top 可以列出CPU使用量的列表，并且可以选择排序的列。\n在菜单选择 VIEW - Flame Graph 可以输出火焰图，很直观地展示出各个函数调用以及占用CPU时间的多少。\n上述导出的是CPU分析的文件，根据请求不同可以导出不同类型的分析文件：\n# CPU分析及运行分析网站 wget http://localhost:8080/debug/pprof/profile go tool pprof -http=:8081 profile # 内存占用分析及运行分析网站 wget http://localhost:8080/debug/pprof/heap go tool pprof -http=:8081 heap # 内存分配分析及运行分析网站 wget http://localhost:8080/debug/pprof/allocs go tool pprof -http=:8081 allocs # Goroutine分析及运行分析网站 wget http://localhost:8080/debug/pprof/goroutine go tool pprof -http=:8081 goroutine # 互斥锁分析及运行分析网站 wget http://localhost:8080/debug/pprof/mutex go tool pprof -http=:8081 mutex # 阻塞分析及运行分析网站 wget http://localhost:8080/debug/pprof/block go tool pprof -http=:8081 block # trace分析及运行分析网站 curl -o trace.out http://localhost:8080/debug/pprof/trace?seconds=5 go tool trace trace.out 每种类型的分析网站菜单都是一样的，而打开的列表、链路图、火焰图则是对应不同资源的情况，不再一一展示。\n2.2 runtime/pprof 生成 pprof 文件 该方式适合于工具型应用，在执行的代码中间通过使用 runtime/pprof 包，生成一个 pprof 文件，然后对该文件以命令行、浏览器等形式进行数据分析。\n示例代码：对一个字符串循环追加内容1000次。\nCPU分析需要分析一段时间内的CPU耗时情况，因此先创建 pprof 文件，执行目标代码，然后再关闭 pprof 文件。执行完该程序后，将会在当前目录保存一个 cpu.pprof 文件，然后可以对该文件进行分析。示例代码：\nimport ( \"runtime/pprof\" ) func main() { cpu_pprof, _ := os.Create(\"cpu.pprof\") _ = pprof.StartCPUProfile(cpu_pprof) // do sth pprof.StopCPUProfile() _ = file.Close() _ = cpu_pprof.Close() } 内存分析是记录某个时刻的内存信息，所以直接创建一个 pprof 文件并写入，然后关闭。示例代码：\nimport ( \"runtime/pprof\" ) func main() { // do sth runtime.GC() heap_pprof, _ := os.Create(\"heap.pprof\") _ = pprof.WriteHeapProfile(heap_pprof) _ = heap_pprof.Close() } 2.2.1 终端命令行分析 和上面通过端口监听方式进入 pprof 命令行类似，不过参数从 url 换成了文件名，在终端执行命令：\n$ go tool pprof cpu.pprof Type: cpu Duration: 10.67s, Total samples = 220ms ( 2.06%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) help 命令查看命令帮助，top 命令查看CPU耗时前10的函数。\n2.2.2 可视化界面分析 上面通过端口监听方式是通过 wget 或 curl 从监听的端口获取 pprof 数据导出到文件，而现在直接就已经生成了一个 pprof 文件，因此我们可以直接在指定端口号运行一个 pprof 分析网站。\ngo tool pprof -http=:8081 cpu.pprof 可视化界面的内容和上面一致，不再重复说明了。\n在 pprof 命令行使用 web 命令也可以在浏览器打开可视化的链路图svg文件，但是不能切换查看其它内容，因此不推荐这种方式。\n2.3 go test 测试用例 还可以通过测试用例来进行程序性能分析。\n代码示例：\n// add.go var datas []string func add(str string) int { data := []byte(str) datas = append(datas, string(data)) return len(datas) } // add_test.go import \"testing\" func TestAdd(t *testing.T) { _ = add(\"go pprof add text\") } func BenchmarkAdd(b *testing.B) { for i := 0; i \u003c b.N; i++ { add(\"go pprof add text\") } } 在终端执行命令，以下命令分别对应CPU分析和内存分析：\ngo test -bench=. -cpuprofile=cpu.profile go test -bench=. -memprofile=mem.profile 将会生成一个 pprof 文件，然后可以指定该文件，执行命令进入命令行分析模式：\ngo tool pprof cpu.profile 或者运行一个 pprof 分析网站：\ngo tool pprof -http=:8081 cpu.profile 3. 实践 3.1 Gin 中间件 对基于 Gin 框架的服务来说，已经开启了端口监听并提供接口服务，可以通过在路由上注册的方式来使用 pprof。\n开源 pprof 中间件：https://github.com/gin-contrib/pprof\n下载包：\ngo get https://github.com/gin-contrib/pprof 在已有代码中添加：\nimport \"github.com/gin-contrib/pprof\" func main() { app := gin.Default() pprof.Register(app) // 在初始化gin实例和监听端口之间添加该行 app.Run(\":8080\") } 然后运行该服务，就可以按照上面描述的方法，通过 pprof 相关命令来进行性能分析。\n该包的实现非常简单，实现文件只有一个：https://github.com/gin-contrib/pprof/blob/master/pprof.go\n核心代码如下，其实就是引入 net/http/pprof 包和 gin 的包，并在路由中给 pprof 的几个路径进行注册：\nfunc RouteRegister(rg *gin.RouterGroup, prefixOptions ...string) { prefix := getPrefix(prefixOptions...) prefixRouter := rg.Group(prefix) { prefixRouter.GET(\"/\", gin.WrapF(pprof.Index)) prefixRouter.GET(\"/cmdline\", gin.WrapF(pprof.Cmdline)) prefixRouter.GET(\"/profile\", gin.WrapF(pprof.Profile)) prefixRouter.POST(\"/symbol\", gin.WrapF(pprof.Symbol)) prefixRouter.GET(\"/symbol\", gin.WrapF(pprof.Symbol)) prefixRouter.GET(\"/trace\", gin.WrapF(pprof.Trace)) prefixRouter.GET(\"/allocs\", gin.WrapH(pprof.Handler(\"allocs\"))) prefixRouter.GET(\"/block\", gin.WrapH(pprof.Handler(\"block\"))) prefixRouter.GET(\"/goroutine\", gin.WrapH(pprof.Handler(\"goroutine\"))) prefixRouter.GET(\"/heap\", gin.WrapH(pprof.Handler(\"heap\"))) prefixRouter.GET(\"/mutex\", gin.WrapH(pprof.Handler(\"mutex\"))) prefixRouter.GET(\"/threadcreate\", gin.WrapH(pprof.Handler(\"threadcreate\"))) } } 3.2 goroutine 泄漏排查 以下用一个 goroutine 泄漏的例子，展示如何通过 pprof 发现定位 goroutine 泄漏问题。\n示例程序如下，开启端口监听后，新建一个通道，每秒钟起100个 goroutine，每个 goroutine 中向通道写入数据，永不从通道读取数据，造成阻塞，创建 goroutine 数量就会一直增加。\npackage main import ( \"fmt\" \"net/http\" _ \"net/http/pprof\" \"time\" ) func main() { go func() { _ = http.ListenAndServe(\":8080\", nil) }() outCh := make(chan int) go func() { if false { // 永不读取 \u003c-outCh } select {} }() // 每秒起100个goroutine，goroutine会阻塞，不释放内存 tick := time.Tick(time.Second / 100) i := 0 for range tick { i++ go alloc(outCh) fmt.Println(\"goroutine %d\", i) } } func alloc(outCh chan\u003c- int) { outCh \u003c- 0 } 先后两次生成 goroutine 分析文件，获得 goroutine 和 goroutine.1：\nwget http://localhost:8080/debug/pprof/goroutine 比较两个 pprof 文件，top 命令可以看到运行到 runtime.gopark 函数的 goroutine 数量增加了2530个，runtime.gopark 函数用于将当前 goroutine 放入等待状态，停止被运行时调度器调度。traces 命令可以看到这些 runtime.gopark 函数调用的调用栈。list 命令可以清楚看到，造成 goroutine 泄漏的 runtime.gopark 函数调用，是由此处 outCh \u003c- 0 被阻塞造成的。\n$ go tool pprof -base goroutine goroutine.1 Type: goroutine Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top Showing nodes accounting for 2530, 100% of 2530 total flat flat% sum% cum cum% 2530 100% 100% 2530 100% runtime.gopark 0 0% 100% 2530 100% main.alloc 0 0% 100% 2530 100% runtime.chansend 0 0% 100% 2530 100% runtime.chansend1 (pprof) traces Type: goroutine -----------+------------------------------------------------------- 2530 runtime.gopark runtime.chansend runtime.chansend1 main.alloc -----------+------------------------------------------------------- (pprof) list main.alloc Total: 2530 ROUTINE ======================== main.alloc in /Users/moondo/go/src/test/cmd/pprof_goroutine_leak.go 0 2530 (flat, cum) 100% of Total . . 29:\tfmt.Println(\"goroutine %d\", i) . . 30:\t} . . 31:} . . 32: . . 33:func alloc(outCh chan\u003c- int) { . 2530 34:\toutCh \u003c- 0 . . 35:} 再对 pprof 文件通过可视化界面进行分析：\ngo tool pprof -http=:8081 goroutine 调用图可以看到几乎所有 goroutine 都走向了 runtime.gopark，也就是 goroutine 被大量暂停了。\n通过火焰图，同样是几乎所有 goroutine 都在 runtime.gopark。\n调整代码，对通道进行读取：\npackage main import ( \"fmt\" \"net/http\" _ \"net/http/pprof\" \"time\" ) func main() { go func() { _ = http.ListenAndServe(\":8080\", nil) }() outCh := make(chan int) go func() { for { \u003c-outCh // 读取通道 } }() // 每秒起100个goroutine，goroutine会阻塞，不释放内存 tick := time.Tick(time.Second / 100) i := 0 for range tick { i++ go alloc(outCh) fmt.Println(\"goroutine %d\", i) } } func alloc(outCh chan\u003c- int) { outCh \u003c- 0 } 先后两次生成 goroutine 分析文件，获得 goroutine 和 goroutine.1：\nwget http://localhost:8080/debug/pprof/goroutine 比较两个 pprof 文件，看到两个文件之间协程间的差别消失了。\n$ go tool pprof -base goroutine goroutine.1 Type: goroutine Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top Showing nodes accounting for 0, 0% of 0 total flat flat% sum% cum cum% 分别查看两个 pprof 文件，大量的 runtime.gopark 函数调用也消失了。\n$ go tool pprof goroutine Type: goroutine Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top Showing nodes accounting for 5, 100% of 5 total Showing top 10 nodes out of 33 flat flat% sum% cum cum% 4 80.00% 80.00% 4 80.00% runtime.gopark 1 20.00% 100% 1 20.00% runtime/pprof.runtime_goroutineProfileWithLabels 0 0% 100% 1 20.00% internal/poll.(*FD).Accept 0 0% 100% 1 20.00% internal/poll.(*FD).Read 0 0% 100% 2 40.00% internal/poll.(*pollDesc).wait 0 0% 100% 2 40.00% internal/poll.(*pollDesc).waitRead (inline) 0 0% 100% 2 40.00% internal/poll.runtime_pollWait 0 0% 100% 1 20.00% main.main 0 0% 100% 1 20.00% main.main.func1 0 0% 100% 1 20.00% main.main.func2 4. 参考 Go 大杀器之性能剖析 PProf gin-contrib/pprof: gin pprof middleware 实战Go内存泄露 - Go语言实战 - SegmentFault 思否 ",
  "wordCount" : "1839",
  "inLanguage": "en",
  "datePublished": "2023-07-25T01:52:12+08:00",
  "dateModified": "2023-07-25T01:52:12+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://example.org/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "http://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go Pprof性能分析
    </h1>
    <div class="post-meta"><span title='2023-07-25 01:52:12 +0800 CST'>July 25, 2023</span>

</div>
  </header> 
  <div class="post-content"><h1 id="1-简介">1. 简介<a hidden class="anchor" aria-hidden="true" href="#1-简介">#</a></h1>
<p>pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。</p>
<p>当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。</p>
<p>pprof 的采集方式分为以下几种：</p>
<ul>
<li>runtime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。</li>
<li>net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。</li>
<li>go test：通过运行测试用例，并指定所需标识来进行采集。</li>
</ul>
<p>pprof 可以分析包含以下几种：</p>
<ul>
<li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。</li>
<li>Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。</li>
<li>Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。</li>
</ul>
<p>采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。</p>
<h1 id="2-使用方式">2. 使用方式<a hidden class="anchor" aria-hidden="true" href="#2-使用方式">#</a></h1>
<h2 id="21-nethttppprof-端口监听">2.1 net/http/pprof 端口监听<a hidden class="anchor" aria-hidden="true" href="#21-nethttppprof-端口监听">#</a></h2>
<p>该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。</p>
<p>代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;net/http/pprof&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">datas</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len: %d&#34;</span>, <span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;go pprof add text&#34;</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">datas</span> = append(<span style="color:#a6e22e">datas</span>, string(<span style="color:#a6e22e">data</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">datas</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>之所以需要对 <code>net/http/pprof</code> 进行空白导入，是因为该包在源代码 pprof.go 中对 /debug/pprof/ 下的几个路径进行了路由注册。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/debug/pprof/&#34;</span>, <span style="color:#a6e22e">Index</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/debug/pprof/cmdline&#34;</span>, <span style="color:#a6e22e">Cmdline</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/debug/pprof/profile&#34;</span>, <span style="color:#a6e22e">Profile</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/debug/pprof/symbol&#34;</span>, <span style="color:#a6e22e">Symbol</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/debug/pprof/trace&#34;</span>, <span style="color:#a6e22e">Trace</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果所要进行分析的程序是一个 Web 服务，已经开启端口监听，对外提供 HTTP 请求接口服务，则只需要对 net/http/pprof 包进行空白导入，即可通过其他命令进行数据分析。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;net/http/pprof&#34;</span>
</span></span></code></pre></div><h3 id="211-生成报告分析">2.1.1 生成报告分析<a hidden class="anchor" aria-hidden="true" href="#211-生成报告分析">#</a></h3>
<p>运行程序，然后在程序运行的期间在浏览器访问网址：http://localhost:8080/debug/pprof/</p>
<p>打开后可以看到：</p>
<p><img loading="lazy" src="https://blog-1304941664.cos.ap-guangzhou.myqcloud.com/article_material/go/pprof_http_brower_report.png" alt="pprof_http_brower_report"  />
</p>
<p>可以看到一些分析指标的数量以及链接，可以点击链接查看详情。这些分析指标对应的含义是：</p>
<ul>
<li>allocs：查看过去所有的内存分配信息。</li>
<li>block：查看导致阻塞同步的堆栈跟踪。</li>
<li>cmdline：当前程序的命令行的完整调用路径。</li>
<li>goroutine：查看当前所有运行的 goroutines 堆栈跟踪。</li>
<li>heap：查看活动对象的内存分配情况。</li>
<li>mutex：查看导致互斥锁的竞争持有者的堆栈跟踪。</li>
<li>profile：进行CPU分析，可以通过GET请求参数指定时间范围。</li>
<li>threadcreate：查看创建新操作系统线程的堆栈跟踪。</li>
<li>trace：生成对目前程序执行的分析文件，用于通过 <code>go tool trace</code> 进行分析，可以通过GET请求参数指定时间范围。</li>
</ul>
<p>以及点击 <a href="http://localhost:8080/debug/pprof/goroutine?debug=2">full goroutine stack dump</a> 将会列出各个协程详细的调用栈信息。</p>
<h3 id="212-终端命令行分析">2.1.2 终端命令行分析<a hidden class="anchor" aria-hidden="true" href="#212-终端命令行分析">#</a></h3>
<p>同样要先运行程序，然后在程序运行的期间终端执行命令，命令参数为 <code>go tool pprof &lt;url&gt;</code> 的格式，不同的 url 表示进行不同的分析类型以及指定的参数。</p>
<p>执行命令时需要程序正在运行状态，以进行信息采集。进入 pprof 的命令行交互后，实际上是将程序当前运行的情况，以 profile 文件保存在目录 <code>~/pprof/</code> 中并进行分析了，程序本身中止运行不会对当前执行 pprof 的命令有所影响。</p>
<p><strong>CPU Profiling</strong></p>
<p>分析程序的CPU使用情况，在终端执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof http://localhost:8080/debug/pprof/profile
</span></span><span style="display:flex;"><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/profile
</span></span><span style="display:flex;"><span>Saved profile in /Users/moondo/pprof/pprof.samples.cpu.006.pb.gz
</span></span><span style="display:flex;"><span>Type: cpu
</span></span><span style="display:flex;"><span>Duration: 30.07s, Total samples <span style="color:#f92672">=</span> 530ms <span style="color:#f92672">(</span> 1.76%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>默认为采集30秒数据，所以执行后需要等待30秒后才可以进入命令行交互模式，可以在请求地址设置参数 <code>seconds=60</code>，表示采集60秒或其它时长的数据进行分析。</p>
<p>查看CPU耗时前10的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 530ms, 100% of 530ms total
</span></span><span style="display:flex;"><span>Showing top <span style="color:#ae81ff">10</span> nodes out of <span style="color:#ae81ff">46</span>
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span><span style="display:flex;"><span>     190ms 35.85% 35.85%      190ms 35.85%  runtime.kevent
</span></span><span style="display:flex;"><span>     110ms 20.75% 56.60%      110ms 20.75%  runtime.pthread_cond_wait
</span></span><span style="display:flex;"><span>      70ms 13.21% 69.81%       70ms 13.21%  syscall.syscall
</span></span><span style="display:flex;"><span>      50ms  9.43% 79.25%       50ms  9.43%  runtime.nanotime1
</span></span><span style="display:flex;"><span>      50ms  9.43% 88.68%       50ms  9.43%  runtime.pthread_cond_signal
</span></span><span style="display:flex;"><span>      30ms  5.66% 94.34%      240ms 45.28%  runtime.netpoll
</span></span><span style="display:flex;"><span>      20ms  3.77% 98.11%       20ms  3.77%  runtime.read
</span></span><span style="display:flex;"><span>      10ms  1.89%   100%       10ms  1.89%  runtime.goready
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%       70ms 13.21%  internal/poll.<span style="color:#f92672">(</span>*FD<span style="color:#f92672">)</span>.Write
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%       70ms 13.21%  internal/poll.ignoringEINTRIO <span style="color:#f92672">(</span>inline<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>还有其它很多命令可以执行 <code>help</code> 查看说明。</p>
<p><strong>Heap Profiling</strong></p>
<p>分析程序的内存使用情况，在终端执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof http://localhost:8080/debug/pprof/heap
</span></span><span style="display:flex;"><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/heap
</span></span><span style="display:flex;"><span>Saved profile in /Users/moondo/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz
</span></span><span style="display:flex;"><span>Type: inuse_space
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>该命令无需等待直接进入命令行，且默认分析的是常驻内存的占用，也可以在参数中选择分析常驻内存占用或者临时的内存分配情况。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 内存占用</span>
</span></span><span style="display:flex;"><span>$ go tool pprof -inuse_space http://localhost:8080/debug/pprof/heap
</span></span><span style="display:flex;"><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/heap
</span></span><span style="display:flex;"><span>Saved profile in /Users/moondo/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.007.pb.gz
</span></span><span style="display:flex;"><span>Type: inuse_space
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 5.29MB, 100% of 5.29MB total
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span><span style="display:flex;"><span>    5.29MB   100%   100%     5.29MB   100%  main.add <span style="color:#f92672">(</span>inline<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%     5.29MB   100%  main.main.func1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 内存分配</span>
</span></span><span style="display:flex;"><span>$ go tool pprof -alloc_objects http://localhost:8080/debug/pprof/heap
</span></span><span style="display:flex;"><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/heap
</span></span><span style="display:flex;"><span>Saved profile in /Users/moondo/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.006.pb.gz
</span></span><span style="display:flex;"><span>Type: alloc_objects
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 196619, 100% of <span style="color:#ae81ff">196675</span> total
</span></span><span style="display:flex;"><span>Dropped <span style="color:#ae81ff">19</span> nodes <span style="color:#f92672">(</span>cum &lt;<span style="color:#f92672">=</span> 983<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">131083</span> 66.65% 66.65%     <span style="color:#ae81ff">131083</span> 66.65%  main.add <span style="color:#f92672">(</span>inline<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">32768</span> 16.66% 83.31%      <span style="color:#ae81ff">32768</span> 16.66%  fmt.Sprintf
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">32768</span> 16.66%   100%     <span style="color:#ae81ff">196619</span>   100%  main.main.func1
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%      <span style="color:#ae81ff">32768</span> 16.66%  log.Printf
</span></span></code></pre></div><p><strong>Goroutine Profiling</strong></p>
<p>分析程序的协程情况，在终端执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof http://localhost:8080/debug/pprof/goroutine
</span></span><span style="display:flex;"><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/goroutine
</span></span><span style="display:flex;"><span>Saved profile in /Users/moondo/pprof/pprof.goroutine.001.pb.gz
</span></span><span style="display:flex;"><span>Type: goroutine
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>该命令无需等待直接进入命令行。</p>
<p>使用traces命令打印所有的调用栈：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> traces
</span></span><span style="display:flex;"><span>Type: goroutine
</span></span><span style="display:flex;"><span>-----------+-------------------------------------------------------
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">1</span>   runtime.gopark
</span></span><span style="display:flex;"><span>             runtime.netpollblock
</span></span><span style="display:flex;"><span>             internal/poll.runtime_pollWait
</span></span><span style="display:flex;"><span>             internal/poll.<span style="color:#f92672">(</span>*pollDesc<span style="color:#f92672">)</span>.wait
</span></span><span style="display:flex;"><span>             internal/poll.<span style="color:#f92672">(</span>*pollDesc<span style="color:#f92672">)</span>.waitRead <span style="color:#f92672">(</span>inline<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>             internal/poll.<span style="color:#f92672">(</span>*FD<span style="color:#f92672">)</span>.Accept
</span></span><span style="display:flex;"><span>             net.<span style="color:#f92672">(</span>*netFD<span style="color:#f92672">)</span>.accept
</span></span><span style="display:flex;"><span>             net.<span style="color:#f92672">(</span>*TCPListener<span style="color:#f92672">)</span>.accept
</span></span><span style="display:flex;"><span>             net.<span style="color:#f92672">(</span>*TCPListener<span style="color:#f92672">)</span>.Accept
</span></span><span style="display:flex;"><span>             net/http.<span style="color:#f92672">(</span>*Server<span style="color:#f92672">)</span>.Serve
</span></span><span style="display:flex;"><span>             net/http.<span style="color:#f92672">(</span>*Server<span style="color:#f92672">)</span>.ListenAndServe
</span></span><span style="display:flex;"><span>             net/http.ListenAndServe <span style="color:#f92672">(</span>inline<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>             main.main
</span></span><span style="display:flex;"><span>             runtime.main
</span></span><span style="display:flex;"><span>-----------+-------------------------------------------------------
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">1</span>   runtime.gopark
</span></span><span style="display:flex;"><span>             time.Sleep
</span></span><span style="display:flex;"><span>             main.main.func1
</span></span><span style="display:flex;"><span>-----------+-------------------------------------------------------
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">1</span>   runtime/pprof.runtime_goroutineProfileWithLabels
</span></span><span style="display:flex;"><span>             runtime/pprof.writeRuntimeProfile
</span></span><span style="display:flex;"><span>             runtime/pprof.writeGoroutine
</span></span><span style="display:flex;"><span>             runtime/pprof.<span style="color:#f92672">(</span>*Profile<span style="color:#f92672">)</span>.WriteTo
</span></span><span style="display:flex;"><span>             net/http/pprof.handler.ServeHTTP
</span></span><span style="display:flex;"><span>             net/http/pprof.Index
</span></span><span style="display:flex;"><span>             net/http.HandlerFunc.ServeHTTP
</span></span><span style="display:flex;"><span>             net/http.<span style="color:#f92672">(</span>*ServeMux<span style="color:#f92672">)</span>.ServeHTTP
</span></span><span style="display:flex;"><span>             net/http.serverHandler.ServeHTTP
</span></span><span style="display:flex;"><span>             net/http.<span style="color:#f92672">(</span>*conn<span style="color:#f92672">)</span>.serve
</span></span><span style="display:flex;"><span>-----------+-------------------------------------------------------
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">1</span>   net/http.<span style="color:#f92672">(</span>*connReader<span style="color:#f92672">)</span>.backgroundRead
</span></span><span style="display:flex;"><span>-----------+-------------------------------------------------------
</span></span></code></pre></div><p>调用栈之间用横线分割，每个调用栈从下面的行调用到上面的行。</p>
<p><strong>Mutex Profiling</strong></p>
<p>互斥锁分析需要在代码中调用 <code>runtime.SetMutexProfileFraction()</code> 并设置参数大于0，以开启互斥锁的采集。</p>
<p>调整一下示例代码，开启多个协程往一个map中写数据，然后用互斥锁造成锁定的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;net/http/pprof&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;runtime&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">SetMutexProfileFraction</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">datas</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">999</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">datas</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后在终端执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof http://localhost:8080/debug/pprof/mutex
</span></span><span style="display:flex;"><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/mutex
</span></span><span style="display:flex;"><span>Saved profile in /Users/moondo/pprof/pprof.contentions.delay.001.pb.gz
</span></span><span style="display:flex;"><span>Type: delay
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>查看互斥量排名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 1.41ms, 100% of 1.41ms total
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span><span style="display:flex;"><span>    1.41ms   100%   100%     1.41ms   100%  sync.<span style="color:#f92672">(</span>*Mutex<span style="color:#f92672">)</span>.Unlock
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%     1.41ms   100%  main.main.func1
</span></span></code></pre></div><p>查看指定函数的代码，可以看到引起互斥锁的函数以及开销：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> list main
</span></span><span style="display:flex;"><span>Total: 1.41ms
</span></span><span style="display:flex;"><span>ROUTINE <span style="color:#f92672">========================</span> main.main.func1 in /Users/moondo/go/src/test/cmd/pprof_http_mutex.go
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     1.41ms <span style="color:#f92672">(</span>flat, cum<span style="color:#f92672">)</span>   100% of Total
</span></span><span style="display:flex;"><span>         .          .     17:	<span style="color:#66d9ef">for</span> i :<span style="color:#f92672">=</span> 0; i &lt; 999; i++ <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         .          .     18:		go func<span style="color:#f92672">(</span>i int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         .          .     19:			m.Lock<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>         .          .     20:			defer m.Unlock<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>         .          .     21:			datas<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> struct<span style="color:#f92672">{}{}</span>
</span></span><span style="display:flex;"><span>         .     1.41ms     22:		<span style="color:#f92672">}(</span>i<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         .          .     23:	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         .          .     24:	_ <span style="color:#f92672">=</span> http.ListenAndServe<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;:8080&#34;</span>, nil<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         .          .     25:<span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Block Profiling</strong></p>
<p>阻塞分析需要在代码中调用 <code>runtime.SetBlockProfileRate()</code> 并设置参数大于0，以开启阻塞情况的采集。</p>
<p>与互斥锁分析的代码类似，但初始化的函数换了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;net/http/pprof&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;runtime&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">SetBlockProfileRate</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">datas</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">999</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">datas</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后在终端执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof http://localhost:8080/debug/pprof/block
</span></span><span style="display:flex;"><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/block
</span></span><span style="display:flex;"><span>Saved profile in /Users/moondo/pprof/pprof.contentions.delay.002.pb.gz
</span></span><span style="display:flex;"><span>Type: delay
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>查看阻塞排名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 133.40ms, 100% of 133.40ms total
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span><span style="display:flex;"><span>  133.40ms   100%   100%   133.40ms   100%  sync.<span style="color:#f92672">(</span>*Mutex<span style="color:#f92672">)</span>.Lock <span style="color:#f92672">(</span>inline<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%   133.40ms   100%  main.main.func1
</span></span></code></pre></div><p>查看指定函数的代码，可以看到引起阻塞的函数以及开销：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> list main
</span></span><span style="display:flex;"><span>Total: 133.40ms
</span></span><span style="display:flex;"><span>ROUTINE <span style="color:#f92672">========================</span> main.main.func1 in /Users/moondo/go/src/test/cmd/pprof_http_block.go
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>   133.40ms <span style="color:#f92672">(</span>flat, cum<span style="color:#f92672">)</span>   100% of Total
</span></span><span style="display:flex;"><span>         .          .     14:func main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         .          .     15:	var m sync.Mutex
</span></span><span style="display:flex;"><span>         .          .     16:	var datas <span style="color:#f92672">=</span> make<span style="color:#f92672">(</span>map<span style="color:#f92672">[</span>int<span style="color:#f92672">]</span>struct<span style="color:#f92672">{})</span>
</span></span><span style="display:flex;"><span>         .          .     17:	<span style="color:#66d9ef">for</span> i :<span style="color:#f92672">=</span> 0; i &lt; 999; i++ <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         .          .     18:		go func<span style="color:#f92672">(</span>i int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         .   133.40ms     19:			m.Lock<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>         .          .     20:			defer m.Unlock<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>         .          .     21:			datas<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> struct<span style="color:#f92672">{}{}</span>
</span></span><span style="display:flex;"><span>         .          .     22:		<span style="color:#f92672">}(</span>i<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         .          .     23:	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         .          .     24:	_ <span style="color:#f92672">=</span> http.ListenAndServe<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;:8080&#34;</span>, nil<span style="color:#f92672">)</span>
</span></span></code></pre></div><h3 id="213-可视化界面分析">2.1.3 可视化界面分析<a hidden class="anchor" aria-hidden="true" href="#213-可视化界面分析">#</a></h3>
<p>还是使用前面提到的，开启一个协程对一个字符串不断地追加内容的例子。该方式将会打开一个有图形的可视化界面，使分析更加直观优雅。使用该方式需要提前安装一个软件 graphviz。</p>
<p>执行程序，然后在终端通过 wget 或 curl 导出CPU分析的文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/profile
</span></span><span style="display:flex;"><span>curl -o profile http://localhost:8080/debug/pprof/profile
</span></span></code></pre></div><p>等待30秒后（CPU分析不带参数默认30秒），会在当前目录保存一个 profile 文件。</p>
<p>然后在终端执行命令，在指定端口号运行一个 pprof 分析网站，这里要换一个端口号，不要和现有程序执行的端口号重复了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 profile
</span></span></code></pre></div><p>自动打开网站，默认显示的是程序调用的链路以及每个调用的耗时，在菜单选择 VIEW - Graph 也可以显示这个。</p>
<p><img loading="lazy" src="https://blog-1304941664.cos.ap-guangzhou.myqcloud.com/article_material/go/pprof_http_brower_ui.png" alt="pprof_http_brower_ui"  />
</p>
<p>代码中主要做的事情是：开启一个协程，然后在循环中不断地给字符串追加内容、向标准输出输出一行日志，然后睡眠10毫秒。在上图左侧的main函数可以看到，往下的箭头指向了三块，分别对应 add 函数耗时 10ms，log.Printf 函数耗时 200ms，time.Sleep 函数耗时 20ms。由此可以分析得出结论，打印日志到标准输出比其他两项更加耗时。</p>
<p>在菜单选择 VIEW - Top 可以列出CPU使用量的列表，并且可以选择排序的列。</p>
<p><img loading="lazy" src="https://blog-1304941664.cos.ap-guangzhou.myqcloud.com/article_material/go/pprof_http_brower_cpu.png" alt="pprof_http_brower_cpu"  />
</p>
<p>在菜单选择 VIEW - Flame Graph 可以输出火焰图，很直观地展示出各个函数调用以及占用CPU时间的多少。</p>
<p><img loading="lazy" src="https://blog-1304941664.cos.ap-guangzhou.myqcloud.com/article_material/go/pprof_http_brower_flame_graph.png" alt="pprof_http_brower_flame_graph"  />
</p>
<p>上述导出的是CPU分析的文件，根据请求不同可以导出不同类型的分析文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># CPU分析及运行分析网站</span>
</span></span><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/profile
</span></span><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 profile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 内存占用分析及运行分析网站</span>
</span></span><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/heap
</span></span><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 heap
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 内存分配分析及运行分析网站</span>
</span></span><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/allocs
</span></span><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 allocs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Goroutine分析及运行分析网站</span>
</span></span><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/goroutine
</span></span><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 goroutine
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 互斥锁分析及运行分析网站</span>
</span></span><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/mutex
</span></span><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 mutex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 阻塞分析及运行分析网站</span>
</span></span><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/block
</span></span><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 block
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># trace分析及运行分析网站</span>
</span></span><span style="display:flex;"><span>curl -o trace.out http://localhost:8080/debug/pprof/trace?seconds<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>go tool trace trace.out
</span></span></code></pre></div><p>每种类型的分析网站菜单都是一样的，而打开的列表、链路图、火焰图则是对应不同资源的情况，不再一一展示。</p>
<h2 id="22-runtimepprof-生成-pprof-文件">2.2 runtime/pprof 生成 pprof 文件<a hidden class="anchor" aria-hidden="true" href="#22-runtimepprof-生成-pprof-文件">#</a></h2>
<p>该方式适合于工具型应用，在执行的代码中间通过使用 runtime/pprof 包，生成一个 pprof 文件，然后对该文件以命令行、浏览器等形式进行数据分析。</p>
<p>示例代码：对一个字符串循环追加内容1000次。</p>
<p>CPU分析需要分析一段时间内的CPU耗时情况，因此先创建 pprof 文件，执行目标代码，然后再关闭 pprof 文件。执行完该程序后，将会在当前目录保存一个 cpu.pprof 文件，然后可以对该文件进行分析。示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;runtime/pprof&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cpu_pprof</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Create</span>(<span style="color:#e6db74">&#34;cpu.pprof&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">StartCPUProfile</span>(<span style="color:#a6e22e">cpu_pprof</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">StopCPUProfile</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">cpu_pprof</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内存分析是记录某个时刻的内存信息，所以直接创建一个 pprof 文件并写入，然后关闭。示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;runtime/pprof&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GC</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">heap_pprof</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Create</span>(<span style="color:#e6db74">&#34;heap.pprof&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">WriteHeapProfile</span>(<span style="color:#a6e22e">heap_pprof</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">heap_pprof</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="221-终端命令行分析">2.2.1 终端命令行分析<a hidden class="anchor" aria-hidden="true" href="#221-终端命令行分析">#</a></h3>
<p>和上面通过端口监听方式进入 pprof 命令行类似，不过参数从 url 换成了文件名，在终端执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof cpu.pprof 
</span></span><span style="display:flex;"><span>Type: cpu
</span></span><span style="display:flex;"><span>Duration: 10.67s, Total samples <span style="color:#f92672">=</span> 220ms <span style="color:#f92672">(</span> 2.06%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> 
</span></span></code></pre></div><p>help 命令查看命令帮助，top 命令查看CPU耗时前10的函数。</p>
<h3 id="222-可视化界面分析">2.2.2 可视化界面分析<a hidden class="anchor" aria-hidden="true" href="#222-可视化界面分析">#</a></h3>
<p>上面通过端口监听方式是通过 wget 或 curl 从监听的端口获取 pprof 数据导出到文件，而现在直接就已经生成了一个 pprof 文件，因此我们可以直接在指定端口号运行一个 pprof 分析网站。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 cpu.pprof
</span></span></code></pre></div><p>可视化界面的内容和上面一致，不再重复说明了。</p>
<p>在 pprof 命令行使用 web 命令也可以在浏览器打开可视化的链路图svg文件，但是不能切换查看其它内容，因此不推荐这种方式。</p>
<h2 id="23-go-test-测试用例">2.3 go test 测试用例<a hidden class="anchor" aria-hidden="true" href="#23-go-test-测试用例">#</a></h2>
<p>还可以通过测试用例来进行程序性能分析。</p>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// add.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">datas</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">datas</span> = append(<span style="color:#a6e22e">datas</span>, string(<span style="color:#a6e22e">data</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">datas</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// add_test.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestAdd</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;go pprof add text&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkAdd</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;go pprof add text&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在终端执行命令，以下命令分别对应CPU分析和内存分析：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go test -bench<span style="color:#f92672">=</span>. -cpuprofile<span style="color:#f92672">=</span>cpu.profile
</span></span><span style="display:flex;"><span>go test -bench<span style="color:#f92672">=</span>. -memprofile<span style="color:#f92672">=</span>mem.profile
</span></span></code></pre></div><p>将会生成一个 pprof 文件，然后可以指定该文件，执行命令进入命令行分析模式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> go tool pprof cpu.profile
</span></span></code></pre></div><p>或者运行一个 pprof 分析网站：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 cpu.profile
</span></span></code></pre></div><h1 id="3-实践">3. 实践<a hidden class="anchor" aria-hidden="true" href="#3-实践">#</a></h1>
<h2 id="31-gin-中间件">3.1 Gin 中间件<a hidden class="anchor" aria-hidden="true" href="#31-gin-中间件">#</a></h2>
<p>对基于 Gin 框架的服务来说，已经开启了端口监听并提供接口服务，可以通过在路由上注册的方式来使用 pprof。</p>
<p>开源 pprof 中间件：https://github.com/gin-contrib/pprof</p>
<p>下载包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go get https://github.com/gin-contrib/pprof
</span></span></code></pre></div><p>在已有代码中添加：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;github.com/gin-contrib/pprof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">app</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">Default</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Register</span>(<span style="color:#a6e22e">app</span>) <span style="color:#75715e">// 在初始化gin实例和监听端口之间添加该行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">app</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后运行该服务，就可以按照上面描述的方法，通过 pprof 相关命令来进行性能分析。</p>
<p>该包的实现非常简单，实现文件只有一个：https://github.com/gin-contrib/pprof/blob/master/pprof.go</p>
<p>核心代码如下，其实就是引入 net/http/pprof 包和 gin 的包，并在路由中给 pprof 的几个路径进行注册：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">RouteRegister</span>(<span style="color:#a6e22e">rg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">RouterGroup</span>, <span style="color:#a6e22e">prefixOptions</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prefix</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getPrefix</span>(<span style="color:#a6e22e">prefixOptions</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prefixRouter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rg</span>.<span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">prefix</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapF</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Index</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/cmdline&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapF</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Cmdline</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/profile&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapF</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Profile</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">POST</span>(<span style="color:#e6db74">&#34;/symbol&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapF</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Symbol</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/symbol&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapF</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Symbol</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/trace&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapF</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Trace</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/allocs&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapH</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Handler</span>(<span style="color:#e6db74">&#34;allocs&#34;</span>)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/block&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapH</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Handler</span>(<span style="color:#e6db74">&#34;block&#34;</span>)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/goroutine&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapH</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Handler</span>(<span style="color:#e6db74">&#34;goroutine&#34;</span>)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/heap&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapH</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Handler</span>(<span style="color:#e6db74">&#34;heap&#34;</span>)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/mutex&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapH</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Handler</span>(<span style="color:#e6db74">&#34;mutex&#34;</span>)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">prefixRouter</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/threadcreate&#34;</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">WrapH</span>(<span style="color:#a6e22e">pprof</span>.<span style="color:#a6e22e">Handler</span>(<span style="color:#e6db74">&#34;threadcreate&#34;</span>)))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="32-goroutine-泄漏排查">3.2 goroutine 泄漏排查<a hidden class="anchor" aria-hidden="true" href="#32-goroutine-泄漏排查">#</a></h2>
<p>以下用一个 goroutine 泄漏的例子，展示如何通过 pprof 发现定位 goroutine 泄漏问题。</p>
<p>示例程序如下，开启端口监听后，新建一个通道，每秒钟起100个 goroutine，每个 goroutine 中向通道写入数据，永不从通道读取数据，造成阻塞，创建 goroutine 数量就会一直增加。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;net/http/pprof&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">outCh</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> { <span style="color:#75715e">// 永不读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">outCh</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 每秒起100个goroutine，goroutine会阻塞，不释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tick</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Tick</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">tick</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">alloc</span>(<span style="color:#a6e22e">outCh</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;goroutine %d&#34;</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">alloc</span>(<span style="color:#a6e22e">outCh</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">outCh</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>先后两次生成 goroutine 分析文件，获得 goroutine 和 goroutine.1：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/goroutine
</span></span></code></pre></div><p>比较两个 pprof 文件，top 命令可以看到运行到 runtime.gopark 函数的 goroutine 数量增加了2530个，runtime.gopark 函数用于将当前 goroutine 放入等待状态，停止被运行时调度器调度。traces 命令可以看到这些 runtime.gopark 函数调用的调用栈。list 命令可以清楚看到，造成 goroutine 泄漏的 runtime.gopark 函数调用，是由此处 <code>outCh &lt;- 0</code> 被阻塞造成的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof -base goroutine goroutine.1
</span></span><span style="display:flex;"><span>Type: goroutine
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 2530, 100% of <span style="color:#ae81ff">2530</span> total
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">2530</span>   100%   100%       <span style="color:#ae81ff">2530</span>   100%  runtime.gopark
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%       <span style="color:#ae81ff">2530</span>   100%  main.alloc
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%       <span style="color:#ae81ff">2530</span>   100%  runtime.chansend
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%       <span style="color:#ae81ff">2530</span>   100%  runtime.chansend1
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> traces
</span></span><span style="display:flex;"><span>Type: goroutine
</span></span><span style="display:flex;"><span>-----------+-------------------------------------------------------
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">2530</span>   runtime.gopark
</span></span><span style="display:flex;"><span>             runtime.chansend
</span></span><span style="display:flex;"><span>             runtime.chansend1
</span></span><span style="display:flex;"><span>             main.alloc
</span></span><span style="display:flex;"><span>-----------+-------------------------------------------------------
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> list main.alloc
</span></span><span style="display:flex;"><span>Total: <span style="color:#ae81ff">2530</span>
</span></span><span style="display:flex;"><span>ROUTINE <span style="color:#f92672">========================</span> main.alloc in /Users/moondo/go/src/test/cmd/pprof_goroutine_leak.go
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">2530</span> <span style="color:#f92672">(</span>flat, cum<span style="color:#f92672">)</span>   100% of Total
</span></span><span style="display:flex;"><span>         .          .     29:		fmt.Println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;goroutine %d&#34;</span>, i<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         .          .     30:	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         .          .     31:<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         .          .     32:
</span></span><span style="display:flex;"><span>         .          .     33:func alloc<span style="color:#f92672">(</span>outCh chan&lt;- int<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         .       <span style="color:#ae81ff">2530</span>     34:	outCh &lt;- <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>         .          .     35:<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>再对 pprof 文件通过可视化界面进行分析：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go tool pprof -http<span style="color:#f92672">=</span>:8081 goroutine
</span></span></code></pre></div><p>调用图可以看到几乎所有 goroutine 都走向了 runtime.gopark，也就是 goroutine 被大量暂停了。</p>
<p><img loading="lazy" src="https://blog-1304941664.cos.ap-guangzhou.myqcloud.com/article_material/go/pprof_goroutine_leak_ui.png" alt="pprof_goroutine_leak_ui"  />
</p>
<p>通过火焰图，同样是几乎所有 goroutine 都在 runtime.gopark。</p>
<p><img loading="lazy" src="https://blog-1304941664.cos.ap-guangzhou.myqcloud.com/article_material/go/pprof_goroutine_leak_flame_graph.png" alt="pprof_goroutine_leak_flame_graph"  />
</p>
<p>调整代码，对通道进行读取：</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;net/http&#34;
	_ &#34;net/http/pprof&#34;
	&#34;time&#34;
)

func main() {
	go func() {
		_ = http.ListenAndServe(&#34;:8080&#34;, nil)
	}()

	outCh := make(chan int)
	go func() {
		for {
			&lt;-outCh // 读取通道
		}
	}()

	// 每秒起100个goroutine，goroutine会阻塞，不释放内存
	tick := time.Tick(time.Second / 100)
	i := 0
	for range tick {
		i++
		go alloc(outCh)
		fmt.Println(&#34;goroutine %d&#34;, i)
	}
}

func alloc(outCh chan&lt;- int) {
	outCh &lt;- 0
}
</code></pre><p>先后两次生成 goroutine 分析文件，获得 goroutine 和 goroutine.1：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget http://localhost:8080/debug/pprof/goroutine
</span></span></code></pre></div><p>比较两个 pprof 文件，看到两个文件之间协程间的差别消失了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof -base goroutine goroutine.1
</span></span><span style="display:flex;"><span>Type: goroutine
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 0, 0% of <span style="color:#ae81ff">0</span> total
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span></code></pre></div><p>分别查看两个 pprof 文件，大量的 runtime.gopark 函数调用也消失了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go tool pprof goroutine
</span></span><span style="display:flex;"><span>Type: goroutine
</span></span><span style="display:flex;"><span>Entering interactive mode <span style="color:#f92672">(</span>type <span style="color:#e6db74">&#34;help&#34;</span> <span style="color:#66d9ef">for</span> commands, <span style="color:#e6db74">&#34;o&#34;</span> <span style="color:#66d9ef">for</span> options<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>pprof<span style="color:#f92672">)</span> top
</span></span><span style="display:flex;"><span>Showing nodes accounting <span style="color:#66d9ef">for</span> 5, 100% of <span style="color:#ae81ff">5</span> total
</span></span><span style="display:flex;"><span>Showing top <span style="color:#ae81ff">10</span> nodes out of <span style="color:#ae81ff">33</span>
</span></span><span style="display:flex;"><span>      flat  flat%   sum%        cum   cum%
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">4</span> 80.00% 80.00%          <span style="color:#ae81ff">4</span> 80.00%  runtime.gopark
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">1</span> 20.00%   100%          <span style="color:#ae81ff">1</span> 20.00%  runtime/pprof.runtime_goroutineProfileWithLabels
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">1</span> 20.00%  internal/poll.<span style="color:#f92672">(</span>*FD<span style="color:#f92672">)</span>.Accept
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">1</span> 20.00%  internal/poll.<span style="color:#f92672">(</span>*FD<span style="color:#f92672">)</span>.Read
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">2</span> 40.00%  internal/poll.<span style="color:#f92672">(</span>*pollDesc<span style="color:#f92672">)</span>.wait
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">2</span> 40.00%  internal/poll.<span style="color:#f92672">(</span>*pollDesc<span style="color:#f92672">)</span>.waitRead <span style="color:#f92672">(</span>inline<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">2</span> 40.00%  internal/poll.runtime_pollWait
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">1</span> 20.00%  main.main
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">1</span> 20.00%  main.main.func1
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span>     0%   100%          <span style="color:#ae81ff">1</span> 20.00%  main.main.func2
</span></span></code></pre></div><h1 id="4-参考">4. 参考<a hidden class="anchor" aria-hidden="true" href="#4-参考">#</a></h1>
<ul>
<li><a href="https://golang2.eddycjy.com/posts/ch6/01-pprof-1/">Go 大杀器之性能剖析 PProf</a></li>
<li><a href="https://github.com/gin-contrib/pprof">gin-contrib/pprof: gin pprof middleware</a></li>
<li><a href="https://segmentfault.com/a/1190000019222661">实战Go内存泄露 - Go语言实战 - SegmentFault 思否</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://example.org/tags/go/">Go</a></li>
      <li><a href="http://example.org/tags/pprof/">pprof</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://example.org/">My New Hugo Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
