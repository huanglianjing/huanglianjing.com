<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - My New Hugo Site">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://example.org/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://example.org/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>JavaScript基础
    </h2>
  </header>
  <div class="entry-content">
    <p>1. JavaScript语法 1.1 在HTML中使用JavaScript 在HTML文档的head元素或body元素中，使用script标签，在其中写入JavaScript代码。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;page name&lt;/title&gt; &lt;script&gt; document.write(&#34;Hello World!&#34;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 也可以把JavaScript代码保存在一个.js文件中，从script标签引用该js文件。
&lt;script src=&#34;example.js&#34;&gt;&lt;/script&gt; script标签放在body中，会在页面加载的时候就执行，加载速度更快。而放在head中会在被调用的时候才执行，W3C建议放在head中，便于管理。
1.2 语法 1.2.1 语句 JavaScript语句末尾可以带分号也可以不带分号，但是建议都带。多条语句放在同一行必须要有分号分隔。
statement statement statement; statement; statement; statement; 注释可以是如下三种方式：
// comment /* comment */ &lt;!-- comment 1.2.2 变量 变量声明和复制：
// 声明 var name; // 赋值 name = &#34;john&#34;; // 未声明变量在使用时自动声明 id = &#34;356734573&#34;; JavaScript中不需要声明类型，是一种弱类型语言，可以在任何时候改变变量的数据类型。
JavaScript有以下几种数据类型：字符串、数值、布尔值、数组、对象。
字符串
字符串由单引号或双引号包含起来。
var a = &#39;fdsfsd&#39;; var b = &#34;dsfsg&#34;; // 字符串拼接 a = &#34;asd&#34; &#43; &#34;33r&#34;; a &#43;= &#34;hehe&#34;; 数值...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:13:11 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to JavaScript基础" href="http://example.org/posts/javascript%E5%9F%BA%E7%A1%80/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>HTML基础知识
    </h2>
  </header>
  <div class="entry-content">
    <p>1. HTML简介 HTML是用来描述网页的一种语言，全称超文本标记语言(Hyper Text Markup Language)，它是一种标记语言，使用标记标签来描述网页，它的语法规则可以定义图片、表格、链接等。
1.1 一个基础例子 一个基础的HTML例子：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;page name&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;title 1&lt;/h1&gt; &lt;h2&gt;sub title&lt;/h2&gt; &lt;p&gt;paragraph text&lt;/p&gt; &lt;h1&gt;title 2&lt;/h1&gt; &lt;p&gt;paragraph text&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 整个文件由html标签包着，其中由分为首部和主体两部分，分别用head标签和body标签包裹。
首部告诉浏览器关于网页的信息，如页面标题，首部包括&lt;head&gt;和&lt;/head&gt;之间的所有内容。其中的title标签定义了网页的标题，meta标签指定了字符编码。
主体包含网页的所有内容和结构，也就是在浏览器直接看到的部分，主体包括&lt;body&gt;和&lt;/body&gt;之间的所有内容。其中的h1标签和h2标签分别是一级标题和二级标题，p标签则是段落。
保存为HTML文件，在浏览器打开后，页面效果如下：
此外，还可以在HTML的首部里增加一些样式，就是style标签。style标签有一个可选的属性type，一般指定为&#34;text/css&#34;。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;page name&lt;/title&gt; &lt;style type=&#34;text/css&#34;&gt; body { background-color: #d2b48c; margin-left: 20%; margin-right: 20%; border: 2px dotted black; padding: 10px 10px 10px 10px; font-family: sans-serif; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;title 1&lt;/h1&gt; &lt;h2&gt;sub title&lt;/h2&gt; &lt;p&gt;paragraph text&lt;/p&gt; &lt;h1&gt;title 2&lt;/h1&gt; &lt;p&gt;paragraph text&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; style标签中的body表示这段配置应用于主体中的body标签。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:12:48 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to HTML基础知识" href="http://example.org/posts/html%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>CSS基础知识
    </h2>
  </header>
  <div class="entry-content">
    <p>1. CSS简介 CSS全称层叠样式表（Cascading Style Sheets），用于描述HTML文档样式。可以写在HTML文档的style标签中，也可以保存在.css文件中被引用。
1.1 语法 CSS规则集由选择器和声明块组成，选择器指向需要设置样式的HTML元素，声明块包含若干条用分号分割的声明，每条声明由一个CSS属性和一个值组成。
以上图片例子对应如下代码：
p { color: red; font-size: 14px; } 注释用/*和*/包裹，可以跨多行。
/*comment*/ 1.2 选择器 选择器用于查找要设置样式的HTML元素，分为以下五类：
简单选择器：根据标签、id、类选取 组合器选择器：根据它们之间的特定关系选取 伪类选择器：根据特定状态选取 伪元素选择器：选取元素的一部分设置样式 属性选择器：根据属性或属性值选取 以下为基本的简单选择器：
元素选择器
根据标签名称选择元素。
p {} id选择器
选择特定id的元素。
#id {} 类选择器
选择特定类的元素。
.class {} 也可以指定特定标签中的特定类。
p.class {} 通用选择器
选择所有元素。
* {} 分组选择器
选择多种条件组合应用同样的样式，减少重复代码。
p, .c1, #id1 {} 后代选择器
选择指定元素后代中的所有标签。
div p {} 子选择器
选择属于指定元素子元素的所有标签。
div &gt; p {} :hover选择器
鼠标指针移到元素上时的样式。
a:hover { background-color:yellow; } 2. 颜色 颜色可以用多种方式来指定，以下为Tomato对应的不同颜色表示方法和值：...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:12:26 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to CSS基础知识" href="http://example.org/posts/css%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>macOS快捷键与常用软件
    </h2>
  </header>
  <div class="entry-content">
    <p>1. macOS快捷键 1.1 按键符号 ⌘ (command) ⌥ (option) ⇧ (shift) ⌃ (control) ↩ (enter) ⌫ (delete) tab space ← → ↑ ↓ 1.2 快捷键 1.2.1 程序 ⌘ &#43; tab 切换程序
⌘ &#43; ` 切换同一个程序不同窗口
⌘ &#43; Q 关闭程序
⌘ &#43; W 关闭窗口
⌘ &#43; N 打开新窗口
⌘ &#43; T 打开新tab
⌘ &#43; M 最小化
⌘ &#43; H 隐藏窗口
⌘ &#43; , 设置
⌘ &#43; ⌫ 删除文件
⌘ &#43; space 聚焦搜索...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:11:23 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to macOS快捷键与常用软件" href="http://example.org/posts/macos%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Homebrew的安装和使用
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 简介 Homebrew 是 macOS 上的一个软件包管理工具，能很方便地安装很多软件包。
官方网站：https://brew.sh/
Homebrew 安装软件时，会先将安装包下载到指定目录，对于非 root 用户会保存在 ~/Library/Caches/Homebrew，对于 root 用户会保存在 /Library/Caches/Homebrew。
然后会将软件安装在 /usr/local/Cellar/ 目录下，再将可执行文件以软链接文件的方式保存在 /usr/local/bin/ 目录下，该目录属于默认 $PATH，所以安装软件后直接输入软件名称就可以执行命令。
2. 安装与配置 安装 Homebrew 只需要执行以下命令，将会获取到安装脚本然后执行：
/bin/bash -c &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&#34; 默认源访问速度较慢，替换为中科大源：
# homebrew目录 cd &#34;$(brew --repo)&#34; git remote -v git remote set-url origin https://mirrors.ustc.edu.cn/brew.git git remote -v # core目录 cd &#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&#34; git remote -v git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git git remote -v 3. 使用命令 更新 Homebrew 至最新：
brew update 支持的所有软件列表：...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:10:50 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to Homebrew的安装和使用" href="http://example.org/posts/homebrew%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Vim操作命令
    </h2>
  </header>
  <div class="entry-content">
    <p>1. Vim介绍 Vim是一个命令行端的文本编辑器，由Vi发展而来，通过各种命令能很方便地对文本进行编辑。
我通常习惯加上alias vi=&#39;vim&#39;，然后直接用vi来打开vim。
2. 打开 使用Vim的第一步是打开它：
# 打开空文件 $ vi # 打开一个文件 $ vi file :e [path] 文件浏览器，可以指定打开路径，或直接打开某个文件 3. 退出 对于很多第一次使用Vim的人，往往会有不知道如何退出编辑器的尴尬。
以下是几种常用的退出方式：
:w 保存，但不退出 :q 直接退出，若有改动则会报错 :qa 退出多个窗口，a表示all，也可用于其他退出命令 :wq 保存并退出 :q! 退出且不保存，会舍弃掉未保存的改动 :wq! 强制保存并退出 :x 退出，若有改动时才保存 4. 配置 保存配置 Vim的配置保存在**/etc/vim/vimrc或~/.vimrc**中，这样每次打开Vim之后保存的配置就生效了。
以下是我的Vim配置：
syntax on set number set nocompatible set showcmd set t_Co=256 set tabstop=4 set softtabstop=4 set shiftwidth=4 set cursorline set showmatch set hlsearch set incsearch set ignorecase set nowrapscan set noswapfile set autochdir set list set listchars=tab:&gt;-,trail:- set shortmess=atI set backspace=indent,eol,start if &amp;diff colors blue endif 输入配置 在命令模式下直接按:加上命令输入配置，配置仅在打开Vim期间生效，关闭后失效。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:10:20 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to Vim操作命令" href="http://example.org/posts/vim%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Kafka再均衡原理及源码分析
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 前言 在Kafka中，当主题的分区数增加、或有新的消费者加入和订阅主题时，就会触发消费组的再均衡（Rebalance）机制，将消费组中各消费者对于主题分区的所有权进行重新的分配。本文主要介绍了再均衡的具体原理，以及结合源码进行深入学习。
1.1 什么是再均衡 一个Kafka集群的体系架构如下图所示，Kafka集群由一至多个broker组成，它们通过ZooKeeper来管理元数据，生产者将消息发送到Kafka集群，而消费者又从Kafka集群中拉取消息。
在Kafka中，消息被发到特定的主题，而一个主题又可以配置为多个分区，因此发往这个主题的消息就会被分配到多个分区上了。
而在一个消费组中，当有多个消费者订阅了这个主题，主题的这些分区就会分别被分配给这些消费者，每个消费者只能拉取被分配到的分区的消息。通过水平扩展多个消费者，可以极大地提升消息的消费效率。
如下图所示，一个主题分成4个分区P0、P1、P2、P3，有两个消费组A和B，它们分别给自己的消费组分配对应的分区，不同的消费者分别对应负责不同的分区。消费组A的四个消费者正好分别分配到一个分区，四个消费者各自拉取分配给自己的分区进行消息消费，而消费组B的两个消费者则分别分配了两个分区。
看起来一切都很稳定，消费组里每个消费者各司其职，都有它们负责的分区。可是实际上分区的分配往往会发生变化，主题的分区数增加，以及消费组的消费者数量增加减少，都会对现有的分区分配造成影响。这时候，就需要重新给消费组的消费者们分配分区，这个过程就叫做消费组的分区再均衡（Rebalance）。
1.2 再均衡触发条件 既然再均衡是把分区分配给消费者这个结果的再次分配，因此触发再均衡的条件大体上可以分为分区数量变化和消费者数量变化。实际上有以下几种情况：
主题的分区数量的变化，由于主题的分区数不能减少，所以这里的变化也就指的是增加 有新的消费者加入消费组 有消费者宕机下线，或遇到长时间的GC或网络延迟等，导致消费者长时间未向GroupCoordinator发送心跳 有消费者主动退出消费组 消费者调用unsubscribe()取消对某主题的订阅 2. 再均衡的三种方案 Kafka历史上有过三个版本的再均衡方案，一步步改进变化成为方案三，也就是现在的方案。
2.1 方案一 Kafka最早的解决方案是通过ZooKeeper的watcher实现的。
每个消费组在ZooKeeper下维护了路径/consumers/[group_id]/ids，消费组的每个消费者在创建的时候，在这个ZooKeeper路径下用临时节点记录自己的消费者id属于此消费组。每个消费者分别在/consumers/[group_id]/ids和/brokers/ids路径上注册一个watcher，以分别监听消费组的消费者变化和broker增减变化。当/consumers/[group_id]/ids路径的子节点发生变化时，表示消费组中的消费者出现了变化，当/brokers/ids路径的子节点发生变化时，表示broker出现了增减。
每个消费者通过watcher监控消费组和Kafka集群的状态，这种方案严重依赖于ZooKeeper，会有两个比较严重的问题：
羊群效应（Herd Effect）：一个被监听的ZooKeeper节点变化，会导致大量的watcher通知被发送给客户端，从而导致在通知期间的其他操作延迟。 脑裂（Split Brain）：每个消费者通过ZooKeeper来保存元数据和再均衡结果，不同消费者在同一时刻可能连接到ZooKeeper集群的不同服务器，看到的数据就可能不一样。 2.2 方案二 将全部消费组分成多个子集，每个消费组的子集在Kafka集群服务端对应一个broker中的GroupCoordinator进行管理，GroupCoordinator是Kafka服务端中一个用于管理消费组的组件。
消费者不再依赖ZooKeeper，而只有GroupCoordinator会在ZooKeeper上添加watcher。消费者在加入或退出消费组时会修改ZooKeeper的元数据，触发GroupCoordinator的watcher，通知GroupCoordinator就开始再均衡操作。
此方案中，分区的分配操作是在服务端的GroupCoordinator中完成的。
此方案的优点是，解决了羊群效应和脑裂问题。但此方案也有缺点，因为分区的分配操作是由GroupCoordinator完成的，因此分区分配策略在服务端之中实现，要实现新的分区分配策略时，就要修改服务端代码或配置，然后重启服务，比较麻烦。另外，自定义分区分配策略和验证需求也会很麻烦。
2.3 方案三 自Kafka 0.9版本又进行了重新设计，将分区分配的工作放到了消费者端进行处理，而消费组的管理工作依然由GroupCoordinator处理。这就让不同的模块关注不同的业务，实现了业务的切分和解耦。接下来主要是介绍方案三的具体细节和实现。
3. 再均衡的原理细节 再均衡分为消费者和服务端两块，消费者主要是负责施行分区分配策略和向服务端的GroupCoordinator发送请求，而服务端的GroupCoordinator则负责为每个消费组维护一个状态机。
3.1 消费者 对于消费者来说，再均衡主要分为四个阶段。
在第一阶段，消费者向Kafka集群某节点发送请求，查找消费组的GroupCoordinator。接着第二阶段是消费者向GroupCoordinator发送请求加入消费组，其中leader消费者根据分区分配策略实施分区。第三阶段将结果同步给消费组的其他各个消费者。最后到达第四阶段，消费组的各个消费者正常工作，并向GroupCoordinator发送心跳。
第一阶段（FIND_COORDINATOR） 再均衡操作的第一阶段是查找GroupCoordinator，这时来了一个新加入的消费者，它会向Kafka集群中的任意一个broker发送GroupCoordinatorRequest请求。而收到请求的broker会根据需要加入的消费组的groupId，返回该消费组对应的GroupCoordinator的具体信息，包括node_id、host和port。
如果消费者已经保存了与消费组对应的GroupCoordinator节点的信息，并且之前与它之间的网络连接是正确的，那么就不需要发送请求，可以直接进入第二阶段。
那么Kafka是怎么决定每个消费组归属于Kafka集群中的哪个borker管理的呢？将每个消费组的groupId计算哈希值，算出其属于主题__consumer_offsets的分区编号，再寻找此分区leader副本所在的broker节点，这个broker节点就是消费组对应的GroupCoordinator节点。
如下图为例，消费者向随机一个broker 1发送GroupCoordinatorRequest请求，broker 1返回GroupCoordinatorResponse，消息中包含了broker 3，也就是说该节点包含了消费组属于的GroupCoordinator。
发送GroupCoordinatorRequest请求的入口是ConsumerCoordinator的GroupCoordinatorRequest()方法。代码如下：
protected synchronized boolean ensureCoordinatorReady(final Timer timer) { // 检查coordinator是否为空，以及与GroupCoordinator的连接是否正常 if (!coordinatorUnknown()) return true; do { if (fatalFindCoordinatorException !...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:09:20 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to Kafka再均衡原理及源码分析" href="http://example.org/posts/kafka%E5%86%8D%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Kafka基础概念
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 介绍 Kafka是LinkedIn采用Scala开发的一个多分区、多副本、基于ZooKeeper协调的分布式消息系统，已被捐献给Apache基金会。kkokokokKafka定位为一个分布式流式处理平台，包含高吞吐、可持久化、可水平扩展、支持流数据处理等特性。
Kafka官网：Apache Kafka
Kafka源码：github.com/apache/kafka
Kafka有三大角色：
消息系统：Kafka具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。 存储系统：Kafka把消息持久化到磁盘，并且有多副本机制，相比内存存储的系统降低了数据丢失的风险。 流式处理平台：Kafka为流式处理框架提供了可靠的数据来源。 2. 基本概念 2.1 体系架构 上图为Kafka的体系架构。一个Kafka体系架构包含若干Producer、若干Broker、若干Consumer，以及一个ZooKeeper集群。
ZooKeeper：负责集群元数据的管理、控制器的选举。 生产者Producer：将消息发送到Broker。 消费者Consumer：从Broker订阅主题并消费消息。 服务代理节点Broker：将收到的消息存储到磁盘。Broker可以看作一个Kafka服务节点或Kafka服务实例，可以将多个Broker运行在不同的服务器上，也可以运行在同一个服务器但是配置不同的端口。 2.2 消息和批次 消息 Kafka的数据单元被称为消息，消息由字节数组组成，对与Kafka来说，消息里的数据没有特别的格式或含义。消息又一个可选的元数据，也就是键，键也是一个字节数组。当消息写入不同分区时会用到键，如为键生成一个散列值，再对主题的分区数取模，同一个键的消息就会被写入相同的分区。
批次 批次就是一组消息，且它们属于同一个主题和分区。将消息分批次写入Kafka，可以减少网络开销，提高效率。
2.3 主题和分区 主题Topic Kafka的消息以主题进行归类，这是一个逻辑上的概念。生产者将消息发送到特定主题，而消费则订阅指定的主题并进行消费以获取消息。
分区Partition 一个主题可以分为多个分区，而一个分区只属于某个主题。同一个主题下，不同分区包含的消息是不同的，分区在存储层面可以看做一个可追加的日志文件，消息追加到分区日志文件后会分配一个特定的偏移量offset。offset是消息在分区的唯一标识，offset可以保证消息在分区内的顺序性，每个分区有分别的offset，在同一个分区的消息将是先进先出的，因此Kafka保证的是分区有序而不是主题有序。
一个主题的各个分区可以分布在不同的broker上，每条消息被发送到broker前，会根据分区规则选择存储到哪个具体的分区。因此在创建主题的时候通过参数指定分区的个数，或者创建完成后修改分区数量，以实现分区水平扩展，突破机器IO的性能瓶颈。
目前Kafka只支持增加分区数，不支持减少分区数。
副本Replica 分区的多副本机制可以增加副本数量以提升容灾能力，同一个分区拥有的副本数量称为复制系数/副本因子。同一个分区的不同副本保存相同的消息，副本之间为一主多从的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker重，当leader副本出现故障时，便从follower副本重新选举新的leader副本对外提供服务。
下图展示了在一个有4个broker的集群中，一个主题配置了3个分区P1、P2、P3。复制系数为3，即每个分区包含有3个副本，一个是leader副本两个是follower副本，这3个副本存储在不同的broker中。
分区的所有副本统称为AR（Assigned Replicas），leader副本以及与leader副本保持一定程度同步的副本组成ISR（In-Sync Replicas），与leader副本同步滞后过多的副本组成OSR（Out-of-Sync Replicas），因此AR=ISR&#43;OSR。leader副本维护和跟踪ISR集合与自己的滞后状态，滞后太多或失效的副本会被从ISR剔除，变为失效副本，OSR中的副本追上leader副本则会被转移至ISR。默认配置下，leader副本发生故障后只会在ISR集合中选举新leader。
偏移量offset 偏移量指消息在日志文件中的相对位置，一个分区中每个消息的偏移量都是唯一的。偏移量会被保存在Kafka内部主题__consumer_offsets中。
以下是三个有含义的偏移量：LogStartOffset、HW、LEO。
LogStartOffset为0，是日志文件的起始处，也就是第一条消息。 HW（High Watermark）俗称高水位，标识了一个offset，消费者只能拉取到HW之前的消息。 LEO（Log End Offset）标识当前日志文件下一条待写入消息的offset，相当于当前日志分区最后一条消息的offset加1。分区的ISR集合每个副本都会维护自身的LEO，而ISR集合中最小的LEO就是分区的HW。 下图展示了一个日志文件，其中HW为6，LEO为9，因此消费者只能拉取偏移量0到5的消息，而下一条写入的消息偏移量将会是9。
2.4 生产者和消费者 生产者 生产者创建消息，并且将消息发不到一个特定的主题。生产者会把消息均衡地分布到主题的所有分区上，分区的选择是通过消息键和分区器来实现的，也可以通过自定义分区器来实现分区选择。
消费者 消费者读取消息，消费者需要订阅一个或多个主题，并按消息生成的顺序读取它们，消费者通过检查消息的偏移量来区分已经读过的消息，从而从该处继续往后读取消息。消费者把每个分区最后读取的消息偏移量保存在ZooKeeper或Kafka上，即使消费者关闭或重启，读取状态也不会丢失。
2.5 broker和集群 broker broker是一个独立的Kafka服务器，它接收来自生产者的消息，设置消息的偏移量，并提交消息到磁盘保存。broker为消费者提供服务，对读取分区请求作出响应，返回提交到磁盘上的消息。
集群 broker是集群的组成部分，每个集群都有一个broker充当集群控制器（Controller）。控制器负责管理工作，如将分区分配给broker，监控broker状态。
3. 服务端 3.1 协议设计 Kafka自定义了一组基于TCP的二进制协议，只要遵守这组协议的格式，就可以向Kafka收发消息。目前包含数十种协议类型，每种协议类型都有对应的请求（Request）和响应（Response）。
协议请求头 协议请求头包含四个域（Field）：
域（Field） 描述（Description） api_key API标识，如PRODUCE、FETCH等表示发送和拉取消息的请求 api_version API版本号 correlation_id 客户端指定的唯一标识请求id，服务端处理完请求会把同样correlation_id回写到响应 client_id 客户端id 协议响应头 协议响应头只有correlation_id，对应发送时的请求头中的correlation_id。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:06:21 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to Kafka基础概念" href="http://example.org/posts/kafka%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Kafka对ZooKeeper的依赖与移除
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 概述 Kafka自2.8开始，移除了之前用于集群的元数据管理、控制器选举等的ZooKeeper的依赖，转而使用Kraft代替，本文来聊聊这一改动的差异和影响。
使用过Kafka都知道，在安装Kafka之前，需要先安装Java和ZooKeeper。需要Java是因为ZooKeeper和Kafka都是用Java编写的，运行需要Java环境。而需要ZooKeeper则是因为，Kafka是使用ZooKeeper来保存集群的元数据信息和消费者信息，进行控制器选举的，因此Kafka的运行需要ZooKeeper的支持。
而在Kafka 2.8中，将移除对ZooKeeper的依赖，转而使用基于KRaft的Quorum控制器。
但是目前据官方声称有些功能还不是太完善，建议先不要用于生产环境。
2. 依赖ZooKeeper的Kafka Kafka体系架构包含若干Producer、若干Broker、若干Consumer，以及一个ZooKeeper集群。Kafka通过ZooKeeper管理集群broker和消费者的元数据，以及用于进行控制器选举。
3. Kafka在ZooKeeper中的数据 3.1 选举控制器 Kafka通过ZooKeeper的临时节点实现选举控制器的功能。
Broker集群中，第一个启动的broker会在ZooKeeper中创建临时节点/controller，从而成为控制器。其他broker启动后也会尝试创建该临时节点，但是会收到节点已存在的异常，从而获知控制器节点已存在，并注册一个监听器。
在控制器关闭或断开连接后，临时节点/controller被删除，其他broker通过监听得到通知并再次尝试创建临时节点/controller，第一个创建成功的broker成为新的控制器，其他获得异常并再次进行监听。
3.2 Broker注册 Kafka的Broker是分布式部署并且相互间独立运行的，但是需要在ZooKeeper进行注册，以将整个集群的Broker服务器管理起来。
ZooKeeper中专门使用Broker节点进行Broker服务器列表的记录，节点路径为/brokers/ids。
每个Broker服务器在启动时，都会到ZooKeeper上进行注册，根据各自的Broker ID创建属于自己的节点，节点路径为/brokers/ids/[0…N]，并且将自己的IP地址和端口等信息写入该节点。
这个节点是一个临时节点，在Broker服务器宕机或是下线后，对应的节点就被删除了。
3.3 Topic注册 在Kafka中，一个Topic的消息会分成多个分区并分布到多个Broker上，这些分区信息以及与Broker的对应关系也都是ZooKeeper维护的，使用专门的Topic节点来记录，节点路径为/brokers/topics。
每一个Kafka的Topic都记录在/brokers/topics/[topic]节点中。
Broker服务器在启动后，会到对应的Topic节点下注册自己的Broker ID，并写入针对该Topic的提供消息存储的分区总数。如节点路径/brokers/topics/[topic]/[broker_id]的节点内容为2，表明该broker在该topic中提供了2个分区的消息存储。
这个节点也是一个临时节点，在Broker服务器宕机或是下线后，对应的节点就被删除了。
3.4 消费者注册 每个消费者在启动的时候，都会在ZooKeeper创建一个属于自己的消费者节点，且为临时节点，这样消费者出现故障或是下线后，对应的消费者节点就会被删除掉。
节点路径为/consumers/[group_id]/ids/[consumer_id]，节点内容为消费者订阅的Topic信息。
每个消费者都会对所属消费者分组的/consumers/[group_id]/ids节点进行Watcher监听，以在消费者新增或减少时，触发消费者负载均衡。同时对/brokers/ids/[0…N]的节点注册监听，在broker服务器列表发生变化时，根据情况决定是否需要消费者的负载均衡。
3.5 消息分区与消费者关系 对于每个消费者分组，Kafka都会为其分配一个全局唯一的Group ID，同时Kafka也会为每个消费者分配一个Consumer ID，通常为Hostname:UUID的形式。
Kafka的设计规定了每个消息分区有且只有一个消费者进行消息消费，因此需要在ZooKeeper记录消息分区与消费者之间的对应关系。节点路径/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]，节点内容为Consumer ID，记录了一个消费者分组对于各个主题的分区所分配的消费者id。
3.6 消息消费进度Offset记录 ZooKeeper同时还记录了消费者对指定消息分区进行消息消费的过程中，定时提交的消费进度，即Offset。这有助于在该消费者重启，或其他消费者接管该消息分区的消息消费后，能够从之前的进度开始继续消息的消费。
节点路径为/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]，节点内容就是Offset值。
4. 为什么要去掉ZooKeeper 在之前的版本中，Kafka依赖于ZooKeeper，需要管理部署两个不同的系统，让运维复杂度翻倍，还让Kafka变得沉重，进而限制了Kafka在轻量环境下的应用。去掉ZooKeeper使得Kafka的部署更简单，更轻量级。 ZooKeeper的分区特性限制Kafka的承载能力。在分区数量多的时候，控制器节点重新选举、分区首领切换需要进行很多的ZooKeeper操作，ZooKeeper存储的元数据数据量也更多，可能导致监听的延时增长或丢失，故障恢复耗时也更长。 Raft协议比ZooKeeper的ZAB协议更易懂，更高效，能提高控制器选举的速度和分区首领选举的速度。 5. 去掉ZooKeeper的Kafka 5.1 体系架构对比 左图所示为目前的结构，有着3个ZooKeeper节点和4个Kafka broker节点，其中橙色的为broker节点中的控制器，控制器会向其他broker节点推送消息。
右图所示为去掉ZooKeeper后的结构，用控制器节点代替了ZooKeeper节点，还有普通的broker节点。控制器节点为元数据分区选举出一个橙色的leader，也称为活动控制器（active controller），其他控制器节点为follower节点。普通节点从leader拉取元数据。控制器进程与broker进程逻辑上分开，但是物理上不必分开，可以部署在同样的节点上。
元数据的更新也从通过向ZooKeeper注册监听的方式修改为普通节点主动从活动控制器拉取的方式。
5.2 quorum控制器 新的架构使用quorum控制器来事件来管理元数据日志，元数据日志包含集群元数据的每次更改，之前存在ZooKeeper的主题、分区、配置等信息都存在这个日志中。控制器节点中leader节点（上方右图的橙色节点）处理所有broker节点的请求，而其他follower节点（上方右图的蓝色节点节点）则复制数据，以在leader节点故障时转移状态为leader。Raft需要超过半数节点运行才能继续运行，所以三个节点的控制器允许一个节点故障，五个节点的控制器允许两个节点的故障。
元数据的更新也从通过向ZooKeeper注册监听的方式修改为普通节点主动从活动控制器拉取的方式。
5.3 启动方式 为Kafka集群生成一个集群ID
$ ./bin/kafka-storage.sh random-uuid xtzWWN4bTjitpL3kfd9s5g 用生成的ID格式化存储目录，对于单节点在该节点运行，对多节点则在每一个节点运行...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:05:51 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to Kafka对ZooKeeper的依赖与移除" href="http://example.org/posts/kafka%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%A7%BB%E9%99%A4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Kafka常见问题
    </h2>
  </header>
  <div class="entry-content">
    <p>为什么Kafka不支持读写分离 在Kafka中，生产者写入消息、消费者读取消息的操作，都是通过和分区的leader副本进行交互的，这是一种主写主读的生产消费模型，并不支持主写从读。原因如下：
数据一致性问题：数据从主节点转到从节点会有一个延时的时间窗口，导致主从节点的数据不一致。 延时问题：类似Redis这种组件的数据存在内存，而Kafka的数据存在磁盘，主从同步会更加耗时，对于延时敏感的应用不适用。 主写从读对于写很少而读很多的情况，可以均摊负载压力。但对于Kafka，每个broker上的读写负载都是一样的，数据写压力很大，主写从读只能分摊很少的负载压力。 Kafka的可靠性 Kafka有如下几个方面配置决定了可靠性：
复制系数 分区的多副本数可以保证数据可靠性，可以在创建主题时配置，也可以在后期修改。越多的副本数可靠性越高，但是副本数太多会引起磁盘、网络带宽的浪费，造成性能下降。一般而言副本数为2能够满足绝大多数场景对可靠性的要求，部分银行会设置为5。同时分配分区副本时引入基架信息（broker.rack参数），也能防止机架整体宕机的风险。
生产者客户端参数acks acks = -1（ 等同于all）时，leader副本在写入本地日志，并且等待所有ISR集合的副本成功写入日志后，才会告知生产者成功提交，最大程度提高消息的可靠性，但性能最差。
acks = 1时，leader副本在写入本地日志之后就会告知生产者已成功提交，若ISR集合的副本没来得及拉取新写入的消息leader副本宕机，此次发送的消息就会丢失。
ack = 0时，生产者把消息发送出去后就认为消息已经成功写入Kafka，性能最好但可靠性最差。
刷盘策略 broker端可以通过设置刷盘策略为同步刷盘，增强数据可靠性，但会对性能造成很大影响。应当使用默认配置，将刷盘策略交由操作系统本身来处理。
发生重复消费的场景 分区再均衡。消费者在消费消息的时候，还未处理完，这时候如果发生了分区再均衡，消费组将不可用，消费者偏移量未提交，完成再均衡后重新消费消息。 消费者消费完消息再提交偏移量，若中间宕机，则重启后再次拉取已消费未提交的消息。 消费者设置了自动提交，在关闭时可能会有部分偏移量未提交，重启后重复消费。 生产者宕机，重启后可能重发数据。 发生消息丢失的场景 消费者拉取数据后，先提交偏移量再消费，若中间宕机，则重启后从新的偏移量开始拉取，前面有部分消息没来得及处理。 生产者acks不是-1，可能有发送不成功或只发给leader副本但该副本宕机的风险，造成消息未实际保存至日志。 </p>
  </div>
  <footer class="entry-footer"><span title='2023-07-25 02:05:30 +0800 CST'>July 25, 2023</span></footer>
  <a class="entry-link" aria-label="post link to Kafka常见问题" href="http://example.org/posts/kafka%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://example.org/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://example.org/">My New Hugo Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
