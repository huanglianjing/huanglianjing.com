<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>huanglianjing</title>
    <link>http://huanglianjing.com/</link>
    <description>Recent content on huanglianjing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 Jul 2023 02:13:11 +0800</lastBuildDate><atom:link href="http://huanglianjing.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript基础</title>
      <link>http://huanglianjing.com/posts/javascript%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 25 Jul 2023 02:13:11 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/javascript%E5%9F%BA%E7%A1%80/</guid>
      <description>1. JavaScript语法 1.1 在HTML中使用JavaScript 在HTML文档的head元素或body元素中，使用script标签，在其中写入JavaScript代码。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;page name&amp;lt;/title&amp;gt; &amp;lt;script&amp;gt; document.write(&amp;#34;Hello World!&amp;#34;); &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 也可以把JavaScript代码保存在一个.js文件中，从script标签引用该js文件。
&amp;lt;script src=&amp;#34;example.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; script标签放在body中，会在页面加载的时候就执行，加载速度更快。而放在head中会在被调用的时候才执行，W3C建议放在head中，便于管理。
1.2 语法 1.2.1 语句 JavaScript语句末尾可以带分号也可以不带分号，但是建议都带。多条语句放在同一行必须要有分号分隔。
statement statement statement; statement; statement; statement; 注释可以是如下三种方式：
// comment /* comment */ &amp;lt;!-- comment 1.2.2 变量 变量声明和复制：
// 声明 var name; // 赋值 name = &amp;#34;john&amp;#34;; // 未声明变量在使用时自动声明 id = &amp;#34;356734573&amp;#34;; JavaScript中不需要声明类型，是一种弱类型语言，可以在任何时候改变变量的数据类型。
JavaScript有以下几种数据类型：字符串、数值、布尔值、数组、对象。
字符串
字符串由单引号或双引号包含起来。
var a = &amp;#39;fdsfsd&amp;#39;; var b = &amp;#34;dsfsg&amp;#34;; // 字符串拼接 a = &amp;#34;asd&amp;#34; + &amp;#34;33r&amp;#34;; a += &amp;#34;hehe&amp;#34;; 数值</description>
    </item>
    
    <item>
      <title>HTML基础知识</title>
      <link>http://huanglianjing.com/posts/html%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 25 Jul 2023 02:12:48 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/html%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>1. HTML简介 HTML是用来描述网页的一种语言，全称超文本标记语言(Hyper Text Markup Language)，它是一种标记语言，使用标记标签来描述网页，它的语法规则可以定义图片、表格、链接等。
1.1 一个基础例子 一个基础的HTML例子：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;page name&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;title 1&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;sub title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;h1&amp;gt;title 2&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 整个文件由html标签包着，其中由分为首部和主体两部分，分别用head标签和body标签包裹。
首部告诉浏览器关于网页的信息，如页面标题，首部包括&amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间的所有内容。其中的title标签定义了网页的标题，meta标签指定了字符编码。
主体包含网页的所有内容和结构，也就是在浏览器直接看到的部分，主体包括&amp;lt;body&amp;gt;和&amp;lt;/body&amp;gt;之间的所有内容。其中的h1标签和h2标签分别是一级标题和二级标题，p标签则是段落。
保存为HTML文件，在浏览器打开后，页面效果如下：
此外，还可以在HTML的首部里增加一些样式，就是style标签。style标签有一个可选的属性type，一般指定为&amp;quot;text/css&amp;quot;。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;page name&amp;lt;/title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; body { background-color: #d2b48c; margin-left: 20%; margin-right: 20%; border: 2px dotted black; padding: 10px 10px 10px 10px; font-family: sans-serif; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;title 1&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;sub title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;h1&amp;gt;title 2&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; style标签中的body表示这段配置应用于主体中的body标签。</description>
    </item>
    
    <item>
      <title>CSS基础知识</title>
      <link>http://huanglianjing.com/posts/css%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 25 Jul 2023 02:12:26 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/css%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>1. CSS简介 CSS全称层叠样式表（Cascading Style Sheets），用于描述HTML文档样式。可以写在HTML文档的style标签中，也可以保存在.css文件中被引用。
1.1 语法 CSS规则集由选择器和声明块组成，选择器指向需要设置样式的HTML元素，声明块包含若干条用分号分割的声明，每条声明由一个CSS属性和一个值组成。
以上图片例子对应如下代码：
p { color: red; font-size: 14px; } 注释用/*和*/包裹，可以跨多行。
/*comment*/ 1.2 选择器 选择器用于查找要设置样式的HTML元素，分为以下五类：
简单选择器：根据标签、id、类选取 组合器选择器：根据它们之间的特定关系选取 伪类选择器：根据特定状态选取 伪元素选择器：选取元素的一部分设置样式 属性选择器：根据属性或属性值选取 以下为基本的简单选择器：
元素选择器
根据标签名称选择元素。
p {} id选择器
选择特定id的元素。
#id {} 类选择器
选择特定类的元素。
.class {} 也可以指定特定标签中的特定类。
p.class {} 通用选择器
选择所有元素。
* {} 分组选择器
选择多种条件组合应用同样的样式，减少重复代码。
p, .c1, #id1 {} 后代选择器
选择指定元素后代中的所有标签。
div p {} 子选择器
选择属于指定元素子元素的所有标签。
div &amp;gt; p {} :hover选择器
鼠标指针移到元素上时的样式。
a:hover { background-color:yellow; } 2. 颜色 颜色可以用多种方式来指定，以下为Tomato对应的不同颜色表示方法和值：</description>
    </item>
    
    <item>
      <title>macOS快捷键与常用软件</title>
      <link>http://huanglianjing.com/posts/macos%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Tue, 25 Jul 2023 02:11:23 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/macos%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</guid>
      <description>1. macOS快捷键 1.1 按键符号 ⌘ (command) ⌥ (option) ⇧ (shift) ⌃ (control) ↩ (enter) ⌫ (delete) tab space ← → ↑ ↓ 1.2 快捷键 1.2.1 程序 ⌘ + tab 切换程序
⌘ + ` 切换同一个程序不同窗口
⌘ + Q 关闭程序
⌘ + W 关闭窗口
⌘ + N 打开新窗口
⌘ + T 打开新tab
⌘ + M 最小化
⌘ + H 隐藏窗口
⌘ + , 设置
⌘ + ⌫ 删除文件
⌘ + space 聚焦搜索</description>
    </item>
    
    <item>
      <title>Homebrew的安装和使用</title>
      <link>http://huanglianjing.com/posts/homebrew%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 25 Jul 2023 02:10:50 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/homebrew%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>1. 简介 Homebrew 是 macOS 上的一个软件包管理工具，能很方便地安装很多软件包。
官方网站：https://brew.sh/
Homebrew 安装软件时，会先将安装包下载到指定目录，对于非 root 用户会保存在 ~/Library/Caches/Homebrew，对于 root 用户会保存在 /Library/Caches/Homebrew。
然后会将软件安装在 /usr/local/Cellar/ 目录下，再将可执行文件以软链接文件的方式保存在 /usr/local/bin/ 目录下，该目录属于默认 $PATH，所以安装软件后直接输入软件名称就可以执行命令。
2. 安装与配置 安装 Homebrew 只需要执行以下命令，将会获取到安装脚本然后执行：
/bin/bash -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;#34; 默认源访问速度较慢，替换为中科大源：
# homebrew目录 cd &amp;#34;$(brew --repo)&amp;#34; git remote -v git remote set-url origin https://mirrors.ustc.edu.cn/brew.git git remote -v # core目录 cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; git remote -v git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git git remote -v 3. 使用命令 更新 Homebrew 至最新：
brew update 支持的所有软件列表：</description>
    </item>
    
    <item>
      <title>Vim操作命令</title>
      <link>http://huanglianjing.com/posts/vim%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 25 Jul 2023 02:10:20 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/vim%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</guid>
      <description>1. Vim介绍 Vim是一个命令行端的文本编辑器，由Vi发展而来，通过各种命令能很方便地对文本进行编辑。
我通常习惯加上alias vi=&#39;vim&#39;，然后直接用vi来打开vim。
2. 打开 使用Vim的第一步是打开它：
# 打开空文件 $ vi # 打开一个文件 $ vi file :e [path] 文件浏览器，可以指定打开路径，或直接打开某个文件 3. 退出 对于很多第一次使用Vim的人，往往会有不知道如何退出编辑器的尴尬。
以下是几种常用的退出方式：
:w 保存，但不退出 :q 直接退出，若有改动则会报错 :qa 退出多个窗口，a表示all，也可用于其他退出命令 :wq 保存并退出 :q! 退出且不保存，会舍弃掉未保存的改动 :wq! 强制保存并退出 :x 退出，若有改动时才保存 4. 配置 保存配置 Vim的配置保存在**/etc/vim/vimrc或~/.vimrc**中，这样每次打开Vim之后保存的配置就生效了。
以下是我的Vim配置：
syntax on set number set nocompatible set showcmd set t_Co=256 set tabstop=4 set softtabstop=4 set shiftwidth=4 set cursorline set showmatch set hlsearch set incsearch set ignorecase set nowrapscan set noswapfile set autochdir set list set listchars=tab:&amp;gt;-,trail:- set shortmess=atI set backspace=indent,eol,start if &amp;amp;diff colors blue endif 输入配置 在命令模式下直接按:加上命令输入配置，配置仅在打开Vim期间生效，关闭后失效。</description>
    </item>
    
    <item>
      <title>Kafka再均衡原理及源码分析</title>
      <link>http://huanglianjing.com/posts/kafka%E5%86%8D%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 25 Jul 2023 02:09:20 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/kafka%E5%86%8D%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>1. 前言 在Kafka中，当主题的分区数增加、或有新的消费者加入和订阅主题时，就会触发消费组的再均衡（Rebalance）机制，将消费组中各消费者对于主题分区的所有权进行重新的分配。本文主要介绍了再均衡的具体原理，以及结合源码进行深入学习。
1.1 什么是再均衡 一个Kafka集群的体系架构如下图所示，Kafka集群由一至多个broker组成，它们通过ZooKeeper来管理元数据，生产者将消息发送到Kafka集群，而消费者又从Kafka集群中拉取消息。
在Kafka中，消息被发到特定的主题，而一个主题又可以配置为多个分区，因此发往这个主题的消息就会被分配到多个分区上了。
而在一个消费组中，当有多个消费者订阅了这个主题，主题的这些分区就会分别被分配给这些消费者，每个消费者只能拉取被分配到的分区的消息。通过水平扩展多个消费者，可以极大地提升消息的消费效率。
如下图所示，一个主题分成4个分区P0、P1、P2、P3，有两个消费组A和B，它们分别给自己的消费组分配对应的分区，不同的消费者分别对应负责不同的分区。消费组A的四个消费者正好分别分配到一个分区，四个消费者各自拉取分配给自己的分区进行消息消费，而消费组B的两个消费者则分别分配了两个分区。
看起来一切都很稳定，消费组里每个消费者各司其职，都有它们负责的分区。可是实际上分区的分配往往会发生变化，主题的分区数增加，以及消费组的消费者数量增加减少，都会对现有的分区分配造成影响。这时候，就需要重新给消费组的消费者们分配分区，这个过程就叫做消费组的分区再均衡（Rebalance）。
1.2 再均衡触发条件 既然再均衡是把分区分配给消费者这个结果的再次分配，因此触发再均衡的条件大体上可以分为分区数量变化和消费者数量变化。实际上有以下几种情况：
主题的分区数量的变化，由于主题的分区数不能减少，所以这里的变化也就指的是增加 有新的消费者加入消费组 有消费者宕机下线，或遇到长时间的GC或网络延迟等，导致消费者长时间未向GroupCoordinator发送心跳 有消费者主动退出消费组 消费者调用unsubscribe()取消对某主题的订阅 2. 再均衡的三种方案 Kafka历史上有过三个版本的再均衡方案，一步步改进变化成为方案三，也就是现在的方案。
2.1 方案一 Kafka最早的解决方案是通过ZooKeeper的watcher实现的。
每个消费组在ZooKeeper下维护了路径/consumers/[group_id]/ids，消费组的每个消费者在创建的时候，在这个ZooKeeper路径下用临时节点记录自己的消费者id属于此消费组。每个消费者分别在/consumers/[group_id]/ids和/brokers/ids路径上注册一个watcher，以分别监听消费组的消费者变化和broker增减变化。当/consumers/[group_id]/ids路径的子节点发生变化时，表示消费组中的消费者出现了变化，当/brokers/ids路径的子节点发生变化时，表示broker出现了增减。
每个消费者通过watcher监控消费组和Kafka集群的状态，这种方案严重依赖于ZooKeeper，会有两个比较严重的问题：
羊群效应（Herd Effect）：一个被监听的ZooKeeper节点变化，会导致大量的watcher通知被发送给客户端，从而导致在通知期间的其他操作延迟。 脑裂（Split Brain）：每个消费者通过ZooKeeper来保存元数据和再均衡结果，不同消费者在同一时刻可能连接到ZooKeeper集群的不同服务器，看到的数据就可能不一样。 2.2 方案二 将全部消费组分成多个子集，每个消费组的子集在Kafka集群服务端对应一个broker中的GroupCoordinator进行管理，GroupCoordinator是Kafka服务端中一个用于管理消费组的组件。
消费者不再依赖ZooKeeper，而只有GroupCoordinator会在ZooKeeper上添加watcher。消费者在加入或退出消费组时会修改ZooKeeper的元数据，触发GroupCoordinator的watcher，通知GroupCoordinator就开始再均衡操作。
此方案中，分区的分配操作是在服务端的GroupCoordinator中完成的。
此方案的优点是，解决了羊群效应和脑裂问题。但此方案也有缺点，因为分区的分配操作是由GroupCoordinator完成的，因此分区分配策略在服务端之中实现，要实现新的分区分配策略时，就要修改服务端代码或配置，然后重启服务，比较麻烦。另外，自定义分区分配策略和验证需求也会很麻烦。
2.3 方案三 自Kafka 0.9版本又进行了重新设计，将分区分配的工作放到了消费者端进行处理，而消费组的管理工作依然由GroupCoordinator处理。这就让不同的模块关注不同的业务，实现了业务的切分和解耦。接下来主要是介绍方案三的具体细节和实现。
3. 再均衡的原理细节 再均衡分为消费者和服务端两块，消费者主要是负责施行分区分配策略和向服务端的GroupCoordinator发送请求，而服务端的GroupCoordinator则负责为每个消费组维护一个状态机。
3.1 消费者 对于消费者来说，再均衡主要分为四个阶段。
在第一阶段，消费者向Kafka集群某节点发送请求，查找消费组的GroupCoordinator。接着第二阶段是消费者向GroupCoordinator发送请求加入消费组，其中leader消费者根据分区分配策略实施分区。第三阶段将结果同步给消费组的其他各个消费者。最后到达第四阶段，消费组的各个消费者正常工作，并向GroupCoordinator发送心跳。
第一阶段（FIND_COORDINATOR） 再均衡操作的第一阶段是查找GroupCoordinator，这时来了一个新加入的消费者，它会向Kafka集群中的任意一个broker发送GroupCoordinatorRequest请求。而收到请求的broker会根据需要加入的消费组的groupId，返回该消费组对应的GroupCoordinator的具体信息，包括node_id、host和port。
如果消费者已经保存了与消费组对应的GroupCoordinator节点的信息，并且之前与它之间的网络连接是正确的，那么就不需要发送请求，可以直接进入第二阶段。
那么Kafka是怎么决定每个消费组归属于Kafka集群中的哪个borker管理的呢？将每个消费组的groupId计算哈希值，算出其属于主题__consumer_offsets的分区编号，再寻找此分区leader副本所在的broker节点，这个broker节点就是消费组对应的GroupCoordinator节点。
如下图为例，消费者向随机一个broker 1发送GroupCoordinatorRequest请求，broker 1返回GroupCoordinatorResponse，消息中包含了broker 3，也就是说该节点包含了消费组属于的GroupCoordinator。
发送GroupCoordinatorRequest请求的入口是ConsumerCoordinator的GroupCoordinatorRequest()方法。代码如下：
protected synchronized boolean ensureCoordinatorReady(final Timer timer) { // 检查coordinator是否为空，以及与GroupCoordinator的连接是否正常 if (!coordinatorUnknown()) return true; do { if (fatalFindCoordinatorException !</description>
    </item>
    
    <item>
      <title>Kafka基础概念</title>
      <link>http://huanglianjing.com/posts/kafka%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Tue, 25 Jul 2023 02:06:21 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/kafka%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
      <description>1. 介绍 Kafka是LinkedIn采用Scala开发的一个多分区、多副本、基于ZooKeeper协调的分布式消息系统，已被捐献给Apache基金会。kkokokokKafka定位为一个分布式流式处理平台，包含高吞吐、可持久化、可水平扩展、支持流数据处理等特性。
Kafka官网：Apache Kafka
Kafka源码：github.com/apache/kafka
Kafka有三大角色：
消息系统：Kafka具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。 存储系统：Kafka把消息持久化到磁盘，并且有多副本机制，相比内存存储的系统降低了数据丢失的风险。 流式处理平台：Kafka为流式处理框架提供了可靠的数据来源。 2. 基本概念 2.1 体系架构 上图为Kafka的体系架构。一个Kafka体系架构包含若干Producer、若干Broker、若干Consumer，以及一个ZooKeeper集群。
ZooKeeper：负责集群元数据的管理、控制器的选举。 生产者Producer：将消息发送到Broker。 消费者Consumer：从Broker订阅主题并消费消息。 服务代理节点Broker：将收到的消息存储到磁盘。Broker可以看作一个Kafka服务节点或Kafka服务实例，可以将多个Broker运行在不同的服务器上，也可以运行在同一个服务器但是配置不同的端口。 2.2 消息和批次 消息 Kafka的数据单元被称为消息，消息由字节数组组成，对与Kafka来说，消息里的数据没有特别的格式或含义。消息又一个可选的元数据，也就是键，键也是一个字节数组。当消息写入不同分区时会用到键，如为键生成一个散列值，再对主题的分区数取模，同一个键的消息就会被写入相同的分区。
批次 批次就是一组消息，且它们属于同一个主题和分区。将消息分批次写入Kafka，可以减少网络开销，提高效率。
2.3 主题和分区 主题Topic Kafka的消息以主题进行归类，这是一个逻辑上的概念。生产者将消息发送到特定主题，而消费则订阅指定的主题并进行消费以获取消息。
分区Partition 一个主题可以分为多个分区，而一个分区只属于某个主题。同一个主题下，不同分区包含的消息是不同的，分区在存储层面可以看做一个可追加的日志文件，消息追加到分区日志文件后会分配一个特定的偏移量offset。offset是消息在分区的唯一标识，offset可以保证消息在分区内的顺序性，每个分区有分别的offset，在同一个分区的消息将是先进先出的，因此Kafka保证的是分区有序而不是主题有序。
一个主题的各个分区可以分布在不同的broker上，每条消息被发送到broker前，会根据分区规则选择存储到哪个具体的分区。因此在创建主题的时候通过参数指定分区的个数，或者创建完成后修改分区数量，以实现分区水平扩展，突破机器IO的性能瓶颈。
目前Kafka只支持增加分区数，不支持减少分区数。
副本Replica 分区的多副本机制可以增加副本数量以提升容灾能力，同一个分区拥有的副本数量称为复制系数/副本因子。同一个分区的不同副本保存相同的消息，副本之间为一主多从的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker重，当leader副本出现故障时，便从follower副本重新选举新的leader副本对外提供服务。
下图展示了在一个有4个broker的集群中，一个主题配置了3个分区P1、P2、P3。复制系数为3，即每个分区包含有3个副本，一个是leader副本两个是follower副本，这3个副本存储在不同的broker中。
分区的所有副本统称为AR（Assigned Replicas），leader副本以及与leader副本保持一定程度同步的副本组成ISR（In-Sync Replicas），与leader副本同步滞后过多的副本组成OSR（Out-of-Sync Replicas），因此AR=ISR+OSR。leader副本维护和跟踪ISR集合与自己的滞后状态，滞后太多或失效的副本会被从ISR剔除，变为失效副本，OSR中的副本追上leader副本则会被转移至ISR。默认配置下，leader副本发生故障后只会在ISR集合中选举新leader。
偏移量offset 偏移量指消息在日志文件中的相对位置，一个分区中每个消息的偏移量都是唯一的。偏移量会被保存在Kafka内部主题__consumer_offsets中。
以下是三个有含义的偏移量：LogStartOffset、HW、LEO。
LogStartOffset为0，是日志文件的起始处，也就是第一条消息。 HW（High Watermark）俗称高水位，标识了一个offset，消费者只能拉取到HW之前的消息。 LEO（Log End Offset）标识当前日志文件下一条待写入消息的offset，相当于当前日志分区最后一条消息的offset加1。分区的ISR集合每个副本都会维护自身的LEO，而ISR集合中最小的LEO就是分区的HW。 下图展示了一个日志文件，其中HW为6，LEO为9，因此消费者只能拉取偏移量0到5的消息，而下一条写入的消息偏移量将会是9。
2.4 生产者和消费者 生产者 生产者创建消息，并且将消息发不到一个特定的主题。生产者会把消息均衡地分布到主题的所有分区上，分区的选择是通过消息键和分区器来实现的，也可以通过自定义分区器来实现分区选择。
消费者 消费者读取消息，消费者需要订阅一个或多个主题，并按消息生成的顺序读取它们，消费者通过检查消息的偏移量来区分已经读过的消息，从而从该处继续往后读取消息。消费者把每个分区最后读取的消息偏移量保存在ZooKeeper或Kafka上，即使消费者关闭或重启，读取状态也不会丢失。
2.5 broker和集群 broker broker是一个独立的Kafka服务器，它接收来自生产者的消息，设置消息的偏移量，并提交消息到磁盘保存。broker为消费者提供服务，对读取分区请求作出响应，返回提交到磁盘上的消息。
集群 broker是集群的组成部分，每个集群都有一个broker充当集群控制器（Controller）。控制器负责管理工作，如将分区分配给broker，监控broker状态。
3. 服务端 3.1 协议设计 Kafka自定义了一组基于TCP的二进制协议，只要遵守这组协议的格式，就可以向Kafka收发消息。目前包含数十种协议类型，每种协议类型都有对应的请求（Request）和响应（Response）。
协议请求头 协议请求头包含四个域（Field）：
域（Field） 描述（Description） api_key API标识，如PRODUCE、FETCH等表示发送和拉取消息的请求 api_version API版本号 correlation_id 客户端指定的唯一标识请求id，服务端处理完请求会把同样correlation_id回写到响应 client_id 客户端id 协议响应头 协议响应头只有correlation_id，对应发送时的请求头中的correlation_id。</description>
    </item>
    
    <item>
      <title>Kafka对ZooKeeper的依赖与移除</title>
      <link>http://huanglianjing.com/posts/kafka%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%A7%BB%E9%99%A4/</link>
      <pubDate>Tue, 25 Jul 2023 02:05:51 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/kafka%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%A7%BB%E9%99%A4/</guid>
      <description>1. 概述 Kafka自2.8开始，移除了之前用于集群的元数据管理、控制器选举等的ZooKeeper的依赖，转而使用Kraft代替，本文来聊聊这一改动的差异和影响。
使用过Kafka都知道，在安装Kafka之前，需要先安装Java和ZooKeeper。需要Java是因为ZooKeeper和Kafka都是用Java编写的，运行需要Java环境。而需要ZooKeeper则是因为，Kafka是使用ZooKeeper来保存集群的元数据信息和消费者信息，进行控制器选举的，因此Kafka的运行需要ZooKeeper的支持。
而在Kafka 2.8中，将移除对ZooKeeper的依赖，转而使用基于KRaft的Quorum控制器。
但是目前据官方声称有些功能还不是太完善，建议先不要用于生产环境。
2. 依赖ZooKeeper的Kafka Kafka体系架构包含若干Producer、若干Broker、若干Consumer，以及一个ZooKeeper集群。Kafka通过ZooKeeper管理集群broker和消费者的元数据，以及用于进行控制器选举。
3. Kafka在ZooKeeper中的数据 3.1 选举控制器 Kafka通过ZooKeeper的临时节点实现选举控制器的功能。
Broker集群中，第一个启动的broker会在ZooKeeper中创建临时节点/controller，从而成为控制器。其他broker启动后也会尝试创建该临时节点，但是会收到节点已存在的异常，从而获知控制器节点已存在，并注册一个监听器。
在控制器关闭或断开连接后，临时节点/controller被删除，其他broker通过监听得到通知并再次尝试创建临时节点/controller，第一个创建成功的broker成为新的控制器，其他获得异常并再次进行监听。
3.2 Broker注册 Kafka的Broker是分布式部署并且相互间独立运行的，但是需要在ZooKeeper进行注册，以将整个集群的Broker服务器管理起来。
ZooKeeper中专门使用Broker节点进行Broker服务器列表的记录，节点路径为/brokers/ids。
每个Broker服务器在启动时，都会到ZooKeeper上进行注册，根据各自的Broker ID创建属于自己的节点，节点路径为/brokers/ids/[0&amp;hellip;N]，并且将自己的IP地址和端口等信息写入该节点。
这个节点是一个临时节点，在Broker服务器宕机或是下线后，对应的节点就被删除了。
3.3 Topic注册 在Kafka中，一个Topic的消息会分成多个分区并分布到多个Broker上，这些分区信息以及与Broker的对应关系也都是ZooKeeper维护的，使用专门的Topic节点来记录，节点路径为/brokers/topics。
每一个Kafka的Topic都记录在/brokers/topics/[topic]节点中。
Broker服务器在启动后，会到对应的Topic节点下注册自己的Broker ID，并写入针对该Topic的提供消息存储的分区总数。如节点路径/brokers/topics/[topic]/[broker_id]的节点内容为2，表明该broker在该topic中提供了2个分区的消息存储。
这个节点也是一个临时节点，在Broker服务器宕机或是下线后，对应的节点就被删除了。
3.4 消费者注册 每个消费者在启动的时候，都会在ZooKeeper创建一个属于自己的消费者节点，且为临时节点，这样消费者出现故障或是下线后，对应的消费者节点就会被删除掉。
节点路径为/consumers/[group_id]/ids/[consumer_id]，节点内容为消费者订阅的Topic信息。
每个消费者都会对所属消费者分组的/consumers/[group_id]/ids节点进行Watcher监听，以在消费者新增或减少时，触发消费者负载均衡。同时对/brokers/ids/[0&amp;hellip;N]的节点注册监听，在broker服务器列表发生变化时，根据情况决定是否需要消费者的负载均衡。
3.5 消息分区与消费者关系 对于每个消费者分组，Kafka都会为其分配一个全局唯一的Group ID，同时Kafka也会为每个消费者分配一个Consumer ID，通常为Hostname:UUID的形式。
Kafka的设计规定了每个消息分区有且只有一个消费者进行消息消费，因此需要在ZooKeeper记录消息分区与消费者之间的对应关系。节点路径/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]，节点内容为Consumer ID，记录了一个消费者分组对于各个主题的分区所分配的消费者id。
3.6 消息消费进度Offset记录 ZooKeeper同时还记录了消费者对指定消息分区进行消息消费的过程中，定时提交的消费进度，即Offset。这有助于在该消费者重启，或其他消费者接管该消息分区的消息消费后，能够从之前的进度开始继续消息的消费。
节点路径为/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]，节点内容就是Offset值。
4. 为什么要去掉ZooKeeper 在之前的版本中，Kafka依赖于ZooKeeper，需要管理部署两个不同的系统，让运维复杂度翻倍，还让Kafka变得沉重，进而限制了Kafka在轻量环境下的应用。去掉ZooKeeper使得Kafka的部署更简单，更轻量级。 ZooKeeper的分区特性限制Kafka的承载能力。在分区数量多的时候，控制器节点重新选举、分区首领切换需要进行很多的ZooKeeper操作，ZooKeeper存储的元数据数据量也更多，可能导致监听的延时增长或丢失，故障恢复耗时也更长。 Raft协议比ZooKeeper的ZAB协议更易懂，更高效，能提高控制器选举的速度和分区首领选举的速度。 5. 去掉ZooKeeper的Kafka 5.1 体系架构对比 左图所示为目前的结构，有着3个ZooKeeper节点和4个Kafka broker节点，其中橙色的为broker节点中的控制器，控制器会向其他broker节点推送消息。
右图所示为去掉ZooKeeper后的结构，用控制器节点代替了ZooKeeper节点，还有普通的broker节点。控制器节点为元数据分区选举出一个橙色的leader，也称为活动控制器（active controller），其他控制器节点为follower节点。普通节点从leader拉取元数据。控制器进程与broker进程逻辑上分开，但是物理上不必分开，可以部署在同样的节点上。
元数据的更新也从通过向ZooKeeper注册监听的方式修改为普通节点主动从活动控制器拉取的方式。
5.2 quorum控制器 新的架构使用quorum控制器来事件来管理元数据日志，元数据日志包含集群元数据的每次更改，之前存在ZooKeeper的主题、分区、配置等信息都存在这个日志中。控制器节点中leader节点（上方右图的橙色节点）处理所有broker节点的请求，而其他follower节点（上方右图的蓝色节点节点）则复制数据，以在leader节点故障时转移状态为leader。Raft需要超过半数节点运行才能继续运行，所以三个节点的控制器允许一个节点故障，五个节点的控制器允许两个节点的故障。
元数据的更新也从通过向ZooKeeper注册监听的方式修改为普通节点主动从活动控制器拉取的方式。
5.3 启动方式 为Kafka集群生成一个集群ID
$ ./bin/kafka-storage.sh random-uuid xtzWWN4bTjitpL3kfd9s5g 用生成的ID格式化存储目录，对于单节点在该节点运行，对多节点则在每一个节点运行</description>
    </item>
    
    <item>
      <title>Kafka常见问题</title>
      <link>http://huanglianjing.com/posts/kafka%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 25 Jul 2023 02:05:30 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/kafka%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid>
      <description>为什么Kafka不支持读写分离 在Kafka中，生产者写入消息、消费者读取消息的操作，都是通过和分区的leader副本进行交互的，这是一种主写主读的生产消费模型，并不支持主写从读。原因如下：
数据一致性问题：数据从主节点转到从节点会有一个延时的时间窗口，导致主从节点的数据不一致。 延时问题：类似Redis这种组件的数据存在内存，而Kafka的数据存在磁盘，主从同步会更加耗时，对于延时敏感的应用不适用。 主写从读对于写很少而读很多的情况，可以均摊负载压力。但对于Kafka，每个broker上的读写负载都是一样的，数据写压力很大，主写从读只能分摊很少的负载压力。 Kafka的可靠性 Kafka有如下几个方面配置决定了可靠性：
复制系数 分区的多副本数可以保证数据可靠性，可以在创建主题时配置，也可以在后期修改。越多的副本数可靠性越高，但是副本数太多会引起磁盘、网络带宽的浪费，造成性能下降。一般而言副本数为2能够满足绝大多数场景对可靠性的要求，部分银行会设置为5。同时分配分区副本时引入基架信息（broker.rack参数），也能防止机架整体宕机的风险。
生产者客户端参数acks acks = -1（ 等同于all）时，leader副本在写入本地日志，并且等待所有ISR集合的副本成功写入日志后，才会告知生产者成功提交，最大程度提高消息的可靠性，但性能最差。
acks = 1时，leader副本在写入本地日志之后就会告知生产者已成功提交，若ISR集合的副本没来得及拉取新写入的消息leader副本宕机，此次发送的消息就会丢失。
ack = 0时，生产者把消息发送出去后就认为消息已经成功写入Kafka，性能最好但可靠性最差。
刷盘策略 broker端可以通过设置刷盘策略为同步刷盘，增强数据可靠性，但会对性能造成很大影响。应当使用默认配置，将刷盘策略交由操作系统本身来处理。
发生重复消费的场景 分区再均衡。消费者在消费消息的时候，还未处理完，这时候如果发生了分区再均衡，消费组将不可用，消费者偏移量未提交，完成再均衡后重新消费消息。 消费者消费完消息再提交偏移量，若中间宕机，则重启后再次拉取已消费未提交的消息。 消费者设置了自动提交，在关闭时可能会有部分偏移量未提交，重启后重复消费。 生产者宕机，重启后可能重发数据。 发生消息丢失的场景 消费者拉取数据后，先提交偏移量再消费，若中间宕机，则重启后从新的偏移量开始拉取，前面有部分消息没来得及处理。 生产者acks不是-1，可能有发送不成功或只发给leader副本但该副本宕机的风险，造成消息未实际保存至日志。 </description>
    </item>
    
    <item>
      <title>Kafka安装、配置与使用</title>
      <link>http://huanglianjing.com/posts/kafka%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 25 Jul 2023 02:04:52 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/kafka%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>1. 安装 1.1 Linux下安装 Kafka运行环境需要先安装好Java环境。
进入官网http://kafka.apache.org/downloads，选择相应的版本的Kafka链接并下载：
$ wget https://downloads.apache.org/kafka/2.8.0/kafka_2.13-2.8.0.tgz 解压安装包
$ tar zxf kafka_2.13-2.8.0.tgz -C /usr/local/ $ ln -s /usr/local/kafka_2.13-2.8.0/ /usr/local/kafka $ cd /usr/local/kafka 启动ZooKeeper
$ ./bin/zookeeper-server-start.sh config/zookeeper.properties # 后台运行 $ nohup ./bin/zookeeper-server-start.sh config/zookeeper.properties &amp;gt;&amp;gt; zookeeper.log 2&amp;gt;&amp;amp;1 &amp;amp; 启动Kafka
$ ./bin/kafka-server-start.sh config/server.properties # 后台运行 $ nohup ./bin/kafka-server-start.sh config/server.properties &amp;gt;&amp;gt; kafka.log 2&amp;gt;&amp;amp;1 &amp;amp; 1.2 MacOS下通过brew安装 在MacOS下，还可以通过brew来安装和运行Kafka，并且可以很方便地启动。
安装：
$ brew install zookeeper $ brew install kafka 启动服务：
$ brew services start zookeeper $ brew services start kafka 如果只是临时启动的话：</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://huanglianjing.com/posts/%E5%85%B3%E4%BA%8E%E6%88%91/</link>
      <pubDate>Tue, 25 Jul 2023 02:04:21 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/%E5%85%B3%E4%BA%8E%E6%88%91/</guid>
      <description>1. 个人介绍 程序员，方向是后台开发，现居深圳，喜欢宅、读书、跑步、写代码。
目前目标是从广度和深度上继续钻研后台开发技术栈，并且希望能早日在自己感兴趣的想法上做出作品成果。
很喜欢Google Jobs的一个slogan，并且希望以此为目标理想：
2. 为什么写博客 开一个博客写一写技术文章、记录一下自己学到的东西和想到的东西这一想法由来已久，最近这几个月来一些生活和工作的体会，让我终于下定决心来建立这个博客，把自己学到的一些知识记录下来。
这样做有很多好处，首先是一些技术学过用过之后，再整理总结然后输出出来，可以更好地加深对技术的理解，真正学会一样知识最好的方式就是把它复述讲解出来，教给别人。其次，以前学过很多东西，但没有整理出来，时间一长很多就忘了，用博客的方式记录下来，就是为了给自己做一个知识的索引，需要时能够立刻找到要用的东西。再者，如果我的文章能够帮助到其他人的学习，解答到读者的困惑，那就更好了。对于我的文章有任何的疑问或者建议，都欢迎来联系我。
3. 联系方式 wechat: moondo_
Email: huanglianjing@gmail.com
GitHub: https://github.com/huanglianjing</description>
    </item>
    
    <item>
      <title>2021年度总结</title>
      <link>http://huanglianjing.com/posts/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 25 Jul 2023 02:03:49 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>2021年已经过去十多天了，被拖延症困扰的我终于决心花些时间来梳理一下过去一年，总结一下我的2021。
生活 自2020年突如其来的新冠肺炎疫情所影响，全世界都发生了巨大的变化，很多人遭遇了种种一生中从没遇到过的，口罩成了出门的标配，时不时哪里出现疫情又会弄的大家都特别紧张。从2020年过年那段时间的慌乱，因为未知的恐惧所以跟任何人距离保持得远远的，到现在国家很好地控制住了疫情，进入稳定防疫防止扩散阶段，大家都不得不学会了去接受现状。总是会想念2019年以及之前不用戴口罩的那些时候，也期盼着未来哪一天能彻底跟新冠告别摘掉口罩，但是目前看还是不太乐观。
这也就导致了2021年一整年，除了省内的团建，还没有过出省玩的机会。一方面是全国各地偶尔发生的疫情，虽然各地都能很快地把疫情扑灭，但是说不准就会不幸撞上，喜提隔离14天套餐，实在是不敢冒这个险。另一方面是国外疫情控制得这个鬼样，出国就是去感受“群体免疫”，签证也不好办，我对国外旅游这一块的未来持比较悲观的态度，后悔疫情前没有多点出去玩。第三方面就是今年工作压力比较大，也没有心情/假期去规划旅游，更多时候是在家宅着。
今年已经不怎么打开PS4和steam玩游戏了，一是没有什么新的游戏二是也没有心情去玩了。PS5倒是准备要买，可是现在官方都没有货，店里问过还要搭多一个手柄和游戏一起买，PS5独占游戏也没有想玩了，这块可以继续持币观望一阵子。以前比较少玩手游的，但是今年英雄联盟手游和金铲铲之战国服上线了，偶尔还会玩一下。我发现自己渐渐地会觉得，比起花几小时打游戏爽一下，自己会更愿意安静地在家待着，刷刷手机和电脑，或者出去走一走，难道这就是心态开始变老了吗。
2021定了一些目标，但是很惭愧的是，其中很多都没有完成，比如指定的长胖10斤、运动次数、学习技术、实现一些其他想法的目标都和计划有着不小的距离。拖延症的毛病很多人都有，我也是一直和拖延症做斗争，但是常常被打败，这块不怪谁只能怪我自己，应该好好反思。
工作 2021年很大的变化就是工作了，先是不得不离开了之前的公司，然后年初很幸运加入了一直很心仪的互联网大厂，成为了一枚大厂螺丝钉。今年在新的工作环境的经历和感受可以分为上下半年两部分。
上半年刚进公司，主要做的就是学习相应的技术栈，熟悉相应的业务和项目，并且接手已有的项目。上半年对工作是有些不习惯的，一方面是工作节奏上不适应，另一方面是工作方法也有待改进。上半年的反馈提到，工作需要更加积极主动，并且需要加强和同事间的沟通。我后来仔细反思复盘，主要还是上家公司和现在公司的风格不同所导致的我对工作的不习惯。在上一家公司我负责的是比较成熟的产品的开发迭代，并且有专门的PM负责沟通和任务安排工作，我只负责完成分派给我的开发任务的需求开发和问题排查修复，不用操心别的。而现在的公司，并不是成熟稳定的版本迭代，也没有一个PM来负责沟通和对接，我身为后端就需要和前端、测试、产品甚至其他对接的部门及时沟通对齐。此外，作为项目的负责人，要有owner意识，不能被动地等着需求过来，要主动跟进各种事情的进度，推动整体项目的进展，甚至还要主动发现需求。这要求自己做事更加积极主动，并且加强和同事之间的沟通，这是比技术能力更加重要的能力。
下半年基本对项目工作熟悉了，做事情更快了，做事考虑的更加全面了。一边吸取上半年的经验教训，一边在下半年注重改掉一些不好的地方，例如多和不同同事沟通交流，负责的事情就一直跟到底，不要让问题拖着烂尾。我们组还有很好的一点就是技术分享的氛围很浓厚，大家也要求要轮流准备分享。我也有研究Kafka和发表文章到内网，并且在组内做了技术分享。这种技术的输出分享能帮到组里的小伙伴，更多的是能让自己成长进步，接下来2022年更需要大力搞多点。
今年来到新的工作环境，能感觉到周围的同事都是很优秀的，有比较就会有压力。有些同事虽然优秀，但也不是遥不可及的，我也在时时督促自己持续地学习和进步，追赶同事们的脚步。
学习 今年换了新的公司和新的业务方向，我们组主要是做广告投放相关的系统，因此专门学习了计算广告方面的知识。深入了解学习过后才知道，互联网时代的广告不是买下一个广告位然后就摆放广告内容，而是分为DSP、SSP、ADX等不同的部分，有的负责管理广告主投放，有的负责管理媒体侧，有的负责实时竞价，给每个广告展示的机会分配相应的展示广告，具体细分还有标签检索、召回、排序等很多部分。一个广告从点开网站或app，到我们在页面上某个广告位看到具体的广告，中间经历了很复杂的一个流程，每一块都大有学问。了解了计算广告的很多业务知识之后，也就懂了为什么那么多网站和app为什么那么多的各种页面广告弹窗广告，影响使用体验，因为网站和app作者可以提供广告展示机会从中赚钱。也懂了为什么字节跳动近些年为什么发展的这么迅猛，因为它抓住了越来越多人的手机使用时间，拥有着恐怖的流量，这个时代是流量为王的时代，有流量就有广告也就有了可观的收入。
因为工作业务原因接手了现有的系统，使用的是世界上最好的语言：PHP。当然这是一个程序员的梗，我们部门已经慢慢在将PHP替换为Go。PHP简单易上手，有其他语言的基础上很快就学会了，但是门槛低相应的上限也低，不能沉浸在PHP固步自封，而要接触更多的技术和语言。
今年投入很多精力学习的一个就是Go，之前几年一直在写C++，转学Go只要适应一下也不难。Go在标准库、第三方库、原理方面要学的挺多的，目前也在一直深入继续学习中。云原生时代，k8s、etcd等很多技术都是用Go开发的，Go在并发方面也有独特的优势。
今年还深入学习了Kafka，了解了其具体的原理以及实用，并且阅读了一部分的源代码，在组内做了一次分享。
数据库是另外一块，今年一直在使用Mysql，也有了解一些其他类型的数据库如Mongodb。数据库这一大块越学习就感觉越是博大精深，2022年值得花时间好好拓展学习一下。
今年一大遗憾就是个人博客没有搭建起来，目前的文章暂时提交到Github的项目上： https://github.com/huanglianjing/blog ，2022年要尽早搭好博客，并且输出更多的技术文章。
开发环境 由于现在工作中公司配的是Macbook，所以就花了些时间适应新的系统的不同，这块还是能挺快适应的。而且macOS也有其独特优势，最大的优势就是自带terminal，和Linux的命令行能有百分之八十左右的相似度，终于不用忍受Windows那个难用的cmd了。还有一个优势就是玩游戏不方面，有效戒除我的英雄联盟和steam网瘾。另外自己也买了Macbook，将自己的开发环境从Windows+Linux换成了macOS+Linux，。
在macOS上也有很多优秀的软件，一些需要花钱买的也感觉挺值的。比如Jetbrains全家桶，堪称macOS最优秀的IDE，虽然有点小贵但是它值得，Jetbrains全家桶对于能想到的语言如C++、Java、Go、Python、PHP等都有对应的IDE提供支持，他们的界面布局还有快捷键都是一致的，就给多语言的开发带来了一致的开发体验。还有一个推荐的软件是MindNode，同时支持Macbook和iPhone的思维导图软件，这样就可以在手机上也能查看编辑电脑上的思维导图，对于喜欢将计划事项做成思维导图的我来说很有用，从Windows下的Freemind简陋的界面换到MindNode简洁美观的界面，看着心情也好一些。
此外手机也从安卓换成了iPhone，主要是考虑今年苹果终于上高刷了，之前60HZ实在不能用，iPhone也的确和Macbook更搭配。从安卓大屏旗舰拿着费劲到iPhone一只手拿着刚刚好，电量目前看来也挺耐用的，各种app都有对应的，唯独有两个工具iOS这边找了一圈没有很满意的。一个是日历软件，Android的谷歌日历挺好用的，但是在iOS下的谷歌日历就卡卡的用得不舒服，暂时没有更好的替代品，iOS自带日历也有不能忍受的点。还有一个是习惯记录工具，之前在安卓用的是Loop，简洁好用而且免费，挑不出任何毛病简直完美，目前在iPhone用的习惯清单反而感觉稍微有点花哨，而且有些地方有时候操作会卡住，将就着用。
接下来有计划自己尝试学习一下iOS开发，并且给自己开发趁手的日历和习惯工具，涉猎一下别的技术栈还是挺有意思的，这个计划的优先级相对比较低，但是用自己写的工具软件想象就很酷。
总结 最后总结一下过去的2021年，总的来说就是，有很多遗憾，也有不少收获和进步。2022年也依旧给自己定了很多计划，依旧要和拖延症持续做斗争。但我可以很乐观地相信，不仅是外部全世界的疫情，还是内部我自己的生活和职业发展，2022年都会往更好发展。2022年我的方向是明确的，但我的目标是有难度的，2022年已来，一年过后再回头看。</description>
    </item>
    
    <item>
      <title>腾讯广告开发笔记</title>
      <link>http://huanglianjing.com/posts/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 25 Jul 2023 02:03:04 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</guid>
      <description>由于工作上负责对接腾讯广告，通过接入腾讯广告来管理广告投放和效果数据的收集、展示，因此对腾讯广告整理了这篇文章，简要介绍腾讯广告是什么，它有什么能力，我们又该如何使用它。
1. 腾讯广告简介 腾讯广告，原称广点通，由于它属于腾讯的广告营销服务线(AMS)有时我们也称它为AMS。腾讯广告是腾讯推出的广告平台，为广告主提供在腾讯自家的应用（如微信、腾讯视频等）的广告位中投放广告的能力，同样身为广告平台的还有字节跳动的巨量引擎（在今日头条、抖音等应用投放广告）、百度、快手等，都是依托于自家的应用流量，以提供广告投放。
1.1 投放应用 腾讯广告支持投放广告的应用主要有以上：微信、QQ、腾讯视频、腾讯新闻、腾讯看点、腾讯音乐、腾讯游戏、优量汇。每个应用又提供了不同的广告形式和广告版为，供广告主选择最合适的，进行广告投放。
1.1.1 微信 在微信上可以投放的广告有朋友圈广告、公众号广告、小程序广告这三种。我们平时在使用微信的时候，经常可以看到这三种形式的广告。
1.1.2 QQ QQ上有手机QQ广告、QQ空间广告这两种形式。
1.1.3 腾讯视频 腾讯视频有闪屏、前贴片、信息流大图等版位可供广告投放展示选择。
1.1.4 常见广告版位 腾讯看点、优量广告、腾讯音乐支持的版位和腾讯视频较为相似，不再一一赘述。总结常见的广告版位有这么几种：
闪屏：在刚打开APP时弹出的开屏广告，用户点击可以跳转到广告页面，或者几秒钟后进入应用。 前贴片：以短视频的形式嵌入到播放的视频的前面几秒。 信息流：在信息流APP中，将广告以原生形式混入信息流内容中，成为其中一个内容，一半还会有个&amp;quot;广告&amp;quot;等字样区别于其他普通的信息流。 横幅：广告固定展示在APP页面的最上面或最下面一条内容。 激励视频：播放一段视频，一定时间之后才可关闭，有时候看完激励视频可以获得游戏道具等奖励。 视频暂停大图：播放视频暂停时，就会在画面中间弹出广告，恢复播放后又消失了。 内容页：在文章底部融入广告内容展示。 具体的各个应用以及支持的广告形式和广告版位可以在帮助文档中详细查看：
https://e.qq.com/ads/helpcenter/detail?cid=2228&amp;amp;pid=4655
1.2 广告投放 腾讯广告投放管理平台（AD.QQ.COM），是为广告主提供的一站式广告投放系统，可触达腾讯生态包括微信朋友圈、微信公众号与小程序、QQ、腾讯信息流、腾讯音乐、腾讯新闻与腾讯视频、优量汇等全域流量，同时，通过广告管理、报表、资产等多种能力，帮助广告主实现营销推广的目标。
广告主在腾讯广告进行广告投放，主要分为三个部分：
开通账户：如何开通系统账户以及分配角色。 广告上新：创建一条广告的标准化流程，以及如何通过工具生产和管理投放所需的物料。 广告优化：广告投放后可通过哪些能力分析广告效果以及进行优化操作。 1.2.1 投放账户 腾讯广告投放账户的多账户管理是通过商务管家来完成的，通过商务管家可以实时、全面的跟踪管理的广告账号投放效果数据，通过免登陆功能进入投放端进行广告投放优化，共享投放的素材、人群包、落地页等资产数据。
1.2.2 广告创建 创建一条完整的广告由创建推广计划、设置广告、设置创意组成。
设置推广计划：计划类型（展示广告计划、搜索广告计划），推广目标（线上商品、应用、网页等），日预算，名称。
设置广告：渠道包，广告版位（朋友圈、公众号、QQ、腾讯新闻等），定向，排期与出价出价，名称。
设置创意：创意形式，素材，创意组件，跳转URL。
1.2.3 广告创建流程概念 推广目标
推广的产品形态，如商品推广、应用推广（iOS应用、Android应用、PC应用），公众号推广、网页推广、门店推广等。
定向
指定要投放或者要排除的用户的属性集合，投放广告选择合适的定向，可以控制什么用户看得到这条广告，什么用户看不到。属性可以是年龄、性别、设备、消费水平、设备品牌型号、地理位置等，还可以设置人群包直接指定用户群。
售卖策略
不同的广告版位支持不同的售卖规则，售卖方式包含以下几种：
CPC：按每次点击付费 CPM：按每千次曝光付费 CPA：按每次下载付费 oCPC：以点击计费的智能出价。选择特定优化目标，并提供期望平均转化成本后，系统预估每一次展示的转化价值，自动出价，按照点击扣费。 oCPM：以展示计费的智能出价。选择特定优化目标，并提供期望平均转化成本后，系统预估每一次展示的转化价值，自动出价，按照展示扣费。 1.2.4 数据分析 数据报表有不同的口径区别，报表口径旨在向您展示不同统计视角下的报表结果，帮助您通过不同的评估视角，了解广告的表现效果。目前平台支持：广告播放、数据上报、激活时间三种报表口径。同一天的报表数据会因不同的报表口径产生差异。
以一条典型的广告转化链路来看，用户的每一个行为都有对应的时间，例如广告曝光的时间、激活发生的时间，这些行为归因到广告上之后，在不同口径的报表下，该行为会统计到不同日期的报表中去。
数据中心通过组合各种维度的查询，通过趋势图、柱状图、饼图等多种图形化或报表形式，及时、直观地掌握投放效果情况。
1.2.5 转化归因 转化归因承载了客户接收数据（点击监测）、客户上报数据（上报行为、上报方式等）、平台归因（归因方式）以及投放对应的标的物、优化目标等概念，是打通数据和投放的重要模块。
2. 控制台 打开控制台链接：https://ad.qq.com/worktable/#/
登录之后可以看到名下的几个投放账户。</description>
    </item>
    
    <item>
      <title>计算广告基础概念</title>
      <link>http://huanglianjing.com/posts/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Tue, 25 Jul 2023 02:02:16 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
      <description>1. 在线广告基础 1.1 在线广告综述 互联网软件产品往往以免费的形式服务用户，这称为免费模式，免费产品在传播信息的流程中，获得了三项可变现的核心资产：
流量。有人在使用产品时，可以在产品本身的功能之外夹带一些付费内容，也就是广告。 数据。在使用产品的过程留下的行为和属性，如浏览过的商品、填写的资料都是数据，基于这些信息可以调整付费投放内容的策略，提高效率。 影响力。产品和内容获得了更高的关注和信任，因此投放的付费内容也获得了更好的关注效果，在投放广告时可以获得品牌溢价。 广告的定义 广告是由已确定的出资人通过各种媒介进行的有关产品（商品、服务和观点）的，通常是有偿的、有组织的、综合的、劝服性的非人员的信息传播活动。
广告活动中有两个主动的参与方：需求方（demand）和供给方（supply）。需求方可以是广告主（advertiser）、代表广告主利益的代理商（agency）或其他技术形态的采买方，供给方可以是媒体或其他变现平台。广告还有一个被动的参与方，即受众（audience）。
广告的目的 在传统媒体时代，传统广告的目的是借助媒体力量来快速接触大量用户，宣传品牌形象，提升中长期购买率与利润空间，这种目的的广告称为品牌广告（brand awareness），品牌广告的广告主一般属于汽车、快消品等传统行业。
很多广告商希望利用广告手段马上带来大量的购买或其他转化行为，这种广告称为效果广告（direct response），效果广告的广告主一般是游戏、电商等行业和一些中小企业。
传统媒体缺乏投送和优化效果广告的能力，数字媒体的出现使效果广告发展起来，使得投送个性化广告更低成本，并且在线服务也能更清楚了解用户的意图。
在线广告表现形式 横幅广告（banner ad）。嵌入页面中的固定大小版面，一般是图片或Flash或HTML5。 文字链广告（textual ad）。搜索广告的主流形式，有时像横幅广告那样占据固定版面，有时穿插在大量内容链接条目中。 富媒体广告（rich media ad）。常见形式有弹窗、全屏等。 视频广告（video ad）。主要形式有视频内容播放前插入广告、信息流中的视频广告、手机游戏的激励视频广告。 交互式广告（playable ad）。用户可以在创意上完成交互的广告。 社交广告（social ad）。在社交网络的信息流中插入广告。 移动广告（mobile ad）。app的开屏广告、横屏广告、积分墙、推荐墙等。 邮件营销广告（Email Direct Marketing，EDM）。通过电子邮件推广信息，容易被当成垃圾软件。 激励广告（incentive ad）。激励用户完成任务，以产生转化，能显著提高转化效率，但用户没有真实需求，后续效果不好。 团购。广告主是本地化的店铺，为了获得新客。 游戏联运。用户在游戏内消费在推广渠道和开发商之间进行分成。 固定位导航。导航网站的固定展示位，一半按时间付费。 1.2 计算广告基础 广告效果产生过程 广告从用户接触开始，到产生最终效果，分为以下六个阶段：
曝光。指广告展现出来的过程。 关注。指用户意识到广告，曝光不一定意味着关注。 理解。受众理解了广告传达的信息。 接受。受众认可广告信息。 保持。广告传达的信息给用户留下记忆，长时间影响选择。 决策。广告产生用户的转化行为。 互联网广告的技术特点 技术和计算导向。在线广告可以进行惊喜的受众定向，有精确的预估和优化能力。 效果的可衡量性。可以记录和优化广告效果。 创意和投放方式的标准化。 媒体概念的多样化。 数据驱动的投放决策。 计算广告的核心问题 计算广告的核心问题，是为一系列用户与上下文的组合找到最合适的广告投放策略，以优化整体广告活动的利润。
在每次广告展示中，有着对应的收入r和成本q，r-q即为这次展示产生的利润。计算广告优化的目标，就是为了让所有的展示对应产生的利润之和最优化，达到最大。
1.3 计算广告常用指标 基础指标 eCPM：千次展示期望收入（expected cost per mille），是点击率和点击价值的乘积，是计算广告和心得量化指标之一。
ROI：投资回报率（return on investment），特定周期内广告投放收回的价值占广告投入的比例。效果广告投放的目的一般都是为了最终的ROI更高，如果最终的ROI &amp;gt; 1，也就是产生的收入大于投放广告的花费，则表示投放广告是赚钱的。</description>
    </item>
    
    <item>
      <title>Hugo的部署与使用</title>
      <link>http://huanglianjing.com/posts/hugo%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 25 Jul 2023 02:01:05 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/hugo%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>1. 简介 Hugo 是一个使用 Go 编写的静态网站生成器，很适合用来部署个人博客网站。
官网：https://gohugo.io/
2. 部署 2.1 在mac部署 安装 Hugo：
brew install hugo 创建站点：
mkdir hugo cd hugo hugo new site huanglianjing.com cd huanglianjing.com 打开 Hugo 的主题列表挑选主题：https://themes.gohugo.io/
下载并设置主题，将会将主题文件下载到 themes 文件夹内：
git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke git submodule add https://github.com/CaiJimmy/hugo-theme-stack.git themes/stack git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/papermod git submodule add https://github.com/Vimux/Mainroad.git themes/mainroad echo &amp;#34;theme = &amp;#39;papermod&amp;#39;&amp;#34; &amp;gt;&amp;gt; hugo.toml 添加文章，将会在 content/posts 下创建文件，然后在创建的 markdown 文件的开头文本后面追加博文内容：
hugo new posts/xxx.md # 将已有内容追加到markdown文件中 cat xxx.</description>
    </item>
    
    <item>
      <title>Markdown语法</title>
      <link>http://huanglianjing.com/posts/markdown%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 25 Jul 2023 01:59:56 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/markdown%E8%AF%AD%E6%B3%95/</guid>
      <description>1. Markdown介绍 Markdown是一种轻量级标记语言，使用纯文本编写有简单格式的文档。Markdown可以支持标题、图片引用、图表、数学表达式，甚至可以用来画流程图。
Markdown文件后缀为.md或.markdown，常用于Github的readme文件和文档编写等，编辑软件推荐Typora，或者Visual Studio Code安装插件Markdown All in One也非常好用。
2. 文本与标题 纯文本直接输入，用\转义特殊字符。
一至六级标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 正文 效果如下：
目录 根据Markdown文件中的标题结构产生层级目录
[toc] 效果如下：
段落 行末用两个以上空格表示换行 line1&amp;lt;space&amp;gt;&amp;lt;space&amp;gt; line2 用空行换行 line1 line2 分隔线 *** --- ___ 效果如下：
文本格式 斜体 *text* _text_ 粗体 **text** __text__ 粗斜体 ***text*** ___text___ 删除线 ~~text~~ 下划线 &amp;lt;u&amp;gt;text&amp;lt;/u&amp;gt; 效果如下：
注释 text可以为任何文本，同一行后面的文本为注释 [text]:commenttext 本行后没有文本时，下一行为注释 [text]: commenttext 脚注 引用脚注，指向脚注名字时会显示文本 text [^1] 声明脚注，带有一个名字和一些文本 [^1]: some comment 效果如下：鼠标移动至1会显示文本</description>
    </item>
    
    <item>
      <title>Go Pprof性能分析</title>
      <link>http://huanglianjing.com/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 25 Jul 2023 01:52:12 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>1. 简介 pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。
当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。
pprof 的采集方式分为以下几种：
runtime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。 net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。 go test：通过运行测试用例，并指定所需标识来进行采集。 pprof 可以分析包含以下几种：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。 采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。
2. 使用方式 2.1 net/http/pprof 端口监听 该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。
代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。
package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; &amp;#34;time&amp;#34; ) var datas []string func main() { go func() { _ = http.</description>
    </item>
    
    <item>
      <title>Go Modules：Go的包管 理</title>
      <link>http://huanglianjing.com/posts/go-modulesgo%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 25 Jul 2023 01:52:02 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go-modulesgo%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>1. Go Modules介绍 Go Modules是Go管理包的依赖的工具，自Go 1.11加入，以解决Go的依赖管理问题，淘汰了旧的GOPATH模式。
旧的GOPATH模式将代码存放在GOPATH/src目录下，通过go get来下载外部依赖包。但是GOPATH模式没有版本控制的概念，无法确保下载的依赖包是期望的版本。因此引入了Go Modules解决这些问题。
2. 使用Go Modules 首先要确保Go升级到了1.11或以上版本。
然后是设置GO111MODULE，GO111MODULE有三个值：off、on和auto（默认值）。
GO111MODULE=off：不支持modules功能，通过GOPATH来查找依赖包。 GO111MODULE=on：使用modules，完全不会通过GOPATH来查找依赖包。 GO111MODULE=auto：根据当前目录决定是否启用modules，当前目录在GOPATH/src之外，且包含go.mod文件或在包含go.mod文件的目录下面，就会启用modules。 设置GO111MODULE：
$ go env -w GO111MODULE=on # 设置GO111MODULE 当启用modules功能时，依赖包存放位置在GOPATH/pkg/mod，并且允许同一个package的多个版本并存，供项目指定引用。
3. go mod go mod带有多个命令，且会在项目中生成和维护go.mod、go.sum两个文件。
3.1 go.mod Go提供了go mod命令来管理包。
新建目录并初始化生成go.mod文件：
$ mkdir hehe $ cd hehe $ go mod init hehe # 初始化go.mod文件 新建go.mod后，当其他源文件引用了任何包时，go get、go build、go mod等命令都会更新go.mod文件，并会自动下载用到的依赖包。
生成的go.mod内容示例如下：
module hehe go 1.15 require ( github.com/labstack/echo v3.3.10+incompatible // indirect github.com/mattn/go-colorable v0.1.1 github.com/mattn/go-isatty v0.0.7 ) exclude ( go.</description>
    </item>
    
    <item>
      <title>Go安装和使用</title>
      <link>http://huanglianjing.com/posts/go%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:34 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>1. 安装 1.1 CentOS安装Go $ yum install golang 1.2 macOS安装Go macOS 可以通过 brew 安装 Go，需要先安装 brew。
$ brew install go 2. 工具 Go的工具链通过go命令配合子命令使用。
常用命令：
build 编译包和依赖 clean 删除目标文件 doc 显示文档 env 显示go环境变量 fmt 格式化代码 get 下载安装包和依赖 install 编译安装包和依赖 list 列出包 run 编译运行程序 test 测试包 version 显示go版本信息 vet 运行工具vet 执行工具：
$ go [commant] // 执行工具 $ go help [commant] // 查看工具文档 2.1 env 显示Go环境变量。
$ go env # 显示所有Go环境变量 $ go env GOPATH # 显示某个环境变量 $ go env -w GO111MODULE=on # 设置Go环境变量 $ go env -u GOPROXY # 取消env配置 GOPATH</description>
    </item>
    
    <item>
      <title>Go标准库：reflect</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93reflect/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:34 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93reflect/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/reflect
Go 标准库 reflect 用于运行时的映射，使程序运行时可以检查和操纵任意类型的对象。例如，在运行时获取一个任意类型 interface{} 的对象，并获取它的动态类型。
获取对象的类型并使用不同的取值方法：
for _, v := range []any{&amp;#34;hi&amp;#34;, 42, func() {}} { switch v := reflect.ValueOf(v); v.Kind() { case reflect.String: fmt.Println(v.String()) case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: fmt.Println(v.Int()) default: fmt.Printf(&amp;#34;unhandled kind %s&amp;#34;, v.Kind()) } } 获取变量的类型：
var x int typ := reflect.TypeOf(x) fmt.Println(typ) 根据函数名调用对应函数：
func add(a int, b int) int { return a + b } var FuncMap = map[string]interface{}{ &amp;#34;add&amp;#34;: add, } funcName := &amp;#34;add&amp;#34; f := reflect.</description>
    </item>
    
    <item>
      <title>Go标准库：strconv</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93strconv/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:34 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93strconv/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/strconv
Go 标准库 strconv 用于字符串和其他类型的相互转化。
数字转化示例：
// 字符串转整数 i, err := strconv.Atoi(&amp;#34;-42&amp;#34;) // 整数转字符串 s := strconv.Itoa(-42) // 字符串转int，指定进制和位数 i, err := strconv.ParseInt(&amp;#34;-42&amp;#34;, 10, 64) // 数字转字符串 s := strconv.FormatInt(-42, 16) 2. 常量与变量 // IntSize int和uint的位数 const IntSize = intSize // ErrRange 值超出范围 var ErrRange = errors.New(&amp;#34;value out of range&amp;#34;) // ErrSyntax 语法错误 var ErrSyntax = errors.New(&amp;#34;invalid syntax&amp;#34;) 3. 函数 // Atoi string转int func Atoi(s string) (int, error) // Itoa int转string func Itoa(i int) string // 其他类型转string func FormatBool(b bool) string func FormatComplex(c complex128, fmt byte, prec, bitSize int) string func FormatFloat(f float64, fmt byte, prec, bitSize int) string func FormatInt(i int64, base int) string func FormatUint(i uint64, base int) string // string转其他类型 func ParseBool(str string) (bool, error) func ParseComplex(s string, bitSize int) (complex128, error) func ParseFloat(s string, bitSize int) (float64, error) func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (uint64, error) </description>
    </item>
    
    <item>
      <title>Go标准库：strings</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93strings/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:34 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93strings/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/strings
Go 标准库 strings 用于字符串相关的操作。
2. 类型 2.1 Builder 类型定义：
// Builder 字符串构建器 type Builder struct { // contains filtered or unexported fields } 方法：
// Cap 容量大小 func (b *Builder) Cap() int // Grow 增加容量 func (b *Builder) Grow(n int) // Len 字符串长度 func (b *Builder) Len() int // Reset 清空 func (b *Builder) Reset() // 返回现有的字符串 func (b *Builder) String() string // 追加内容 func (b *Builder) Write(p []byte) (int, error) func (b *Builder) WriteString(s string) (int, error) 2.</description>
    </item>
    
    <item>
      <title>Go标准库：time</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93time/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:34 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93time/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/time
Go 标准库 time 用于测量和展示时间。
一个计算代码耗时的例子：
start := time.Now() // do sth. end := time.Now elapsed := end.Sub(start) 2. 常量 时间单位常量：
const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) 月份常量：
const ( January Month = 1 + iota February March April May June July August September October November December ) 星期常量：</description>
    </item>
    
    <item>
      <title>Go标准库：context</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93context/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:33 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93context/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/context
Go 标准库 context 用于在函数调用、API调用、进程调用间传递上下文。
Go官方建议不要将 context 定义在其他结构体中，将 context 作为独立的参数传递给需要的函数且应该是首个参数，变量名一般使用 ctx。示例如下：
func DoSomething(ctx context.Context, arg Arg) error { // ... use ctx ... } context 在多个协程中同时使用是安全的。
2. 类型 2.1 Context 类型定义：
// Context 上下文 type Context interface { Deadline() (deadline time.Time, ok bool) // 被取消的时间 Done() &amp;lt;-chan struct{} // 返回一个通道，context被取消时关闭 Err() error // Done未关闭时返回nil，关闭时返回关闭原因 Value(key any) any // 获取key对应的val } 方法：
// Background 返回一个空的context，不会被取消，没有值，没有deadline，通常用于主函数、初始化、测试、最上层接收请求时 func Background() Context // TODO 返回一个空的context，不确定会用到context时使用 func TODO() Context // WithValue 返回父context的复制，并关联key-val func WithValue(parent Context, key, val any) Context 2.</description>
    </item>
    
    <item>
      <title>Go标准库：errors</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93errors/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:33 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93errors/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/errors
Go 标准库 errors 用于操作error。
如果一个error e包含以下任一方法，则可以包裹另一个error。
Unwrap() error Unwrap() []error 自定义error结构体示例：
type MyError struct { When time.Time What string } func (e MyError) Error() string { return fmt.Sprintf(&amp;#34;%v: %v&amp;#34;, e.When, e.What) } err := MyError{ time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC), &amp;#34;the file system has gone away&amp;#34;, } fmt.Println(err) 2. 函数 // New 创建error func New(text string) error // As err是否和target类型匹配，如果是则设置target的内容 func As(err error, target any) bool // Is err是否和target类型匹配 func Is(err, target error) bool // Join 将多个error包裹起来 func Join(errs .</description>
    </item>
    
    <item>
      <title>Go标准库：fmt</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93fmt/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:33 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93fmt/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/fmt
Go 标准库之 fmt 包实现了格式化 IO，也就是类似于 C 语言的 printf 和 scanf 方式的格式化。
控制格式化的字符串中，以百分号（%）作为格式的通配符，后面跟着不同的字母表示不同的类型格式。例如 %d 表示10进制整数，于是有以下例子：
import &amp;#34;fmt&amp;#34; func fmtTest() { i := 23 str := &amp;#34;good&amp;#34; fmt.Printf(&amp;#34;%d:%s\n&amp;#34;, i, str) } /* 输出结果 23:good */ %d 表示一个10进制整数，而 fmt.Printf() 方法在它的首个格式化字符串参数中找到它后，就从后续的参数里取到变量 i，将变量 i 的值输出到 %d 所占的位置。如果格式化字符串中包含多个以 % 表示的格式，就会依次从后面的参数中取参数值以格式所对应的类型，输出到那个位置。
2. 格式 通用格式：
%v 任何值的默认格式，对于结构体只会显示每个成员的值 %+v 对于结构体还会显示每个成员的字段名称 %#v Go语法的值，还会显示结构体的类型名 %T 值的类型 %% 表示百分号% 使用 %v 对于一些复合结构所打印的格式如下：
struct: {field0 field1 ...} array, slice: [elem0 elem1 .</description>
    </item>
    
    <item>
      <title>Go标准库：json</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93json/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:33 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93json/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/encoding/json
Go 标准库 encoding/json 用于进行json的编码和解码。
结构体编码为字符串示例：
type People struct { Name string `json:&amp;#34;name&amp;#34;` Age int64 `json:&amp;#34;age&amp;#34;` } p := People{Name: &amp;#34;Moondo&amp;#34;, Age: 10} marshal, err := json.Marshal(p) fmt.Printf(&amp;#34;%s\n&amp;#34;, marshal) 字符串解码为结构体示例：
type People struct { Name string `json:&amp;#34;name&amp;#34;` Age int64 `json:&amp;#34;age&amp;#34;` } str := &amp;#34;{\&amp;#34;name\&amp;#34;:\&amp;#34;Moondo\&amp;#34;,\&amp;#34;age\&amp;#34;:10}&amp;#34; var p People err := json.Unmarshal([]byte(str), &amp;amp;p) fmt.Printf(&amp;#34;%s\n&amp;#34;, p.Name) 2. 类型 2.1 RawMessage 类型定义：
// RawMessage json字符串 type RawMessage []byte 方法：
// MarshalJSON 编码并返回 func (m RawMessage) MarshalJSON() ([]byte, error) // UnmarshalJSON 从data赋值自身 func (m *RawMessage) UnmarshalJSON(data []byte) error 2.</description>
    </item>
    
    <item>
      <title>Go标准库：log</title>
      <link>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93log/</link>
      <pubDate>Tue, 25 Jul 2023 01:51:33 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E6%A0%87%E5%87%86%E5%BA%93log/</guid>
      <description>1. 介绍 文档地址：https://pkg.go.dev/log
Go 标准库 log 用于实现简单的日志打印功能。
指定日志文件打印日志：
type People struct { name string age int64 } func main() { logFile, _ := os.OpenFile(&amp;#34;log/info.log&amp;#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) logger := log.New(logFile, &amp;#34;&amp;#34;, log.Ldate|log.Ltime) p := People{name: &amp;#34;moondo&amp;#34;, age: 20} logger.Printf(&amp;#34;%#v&amp;#34;, p) } 2. 常量 前缀常量，定义了日志每一行的前缀，各选项可以通过或运算组合起来：
const ( Ldate = 1 &amp;lt;&amp;lt; iota // the date in the local time zone: 2009/01/23 Ltime // the time in the local time zone: 01:23:23 Lmicroseconds // microsecond resolution: 01:23:23.</description>
    </item>
    
    <item>
      <title>Git基础概念与常用命令</title>
      <link>http://huanglianjing.com/posts/git%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 16 Jul 2023 19:02:11 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/git%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>1. 基础概念 仓库
每个项目整个文件夹称为一个仓库repository，仓库中包含零到多个文件，仓库的改动由链状的提交commit所表示，这些提交又分布在不同的分支branch上。每个仓库都有一个起始默认的仓库master/main，然后新建和删除不同的分支，分支之间可以相互合并，以达到多人共同开发同一个项目。
HEAD表示当前指向的提交。
远程仓库
origin表示远程仓库，每个仓库包含本地仓库和对应的远程仓库，例如对应为dev和origin/dev，可以从远程仓库分支拉取更新到本地，以及将本地提交的修改推送到远程分支。
1.1 文件状态 对于Git项目，仓库文件夹中的文件有如下几种状态：
untracked/未追踪
未追踪的文件就是临时存在当前仓库文件夹中，但是并未包含在仓库中的文件，一般是新增的准备加入仓库中的文件，或是产生的日志文件等临时文件。
未追踪的文件如果不想加到仓库中，而且也不想通过 git status 看到，可以将文件规则加到.gitignore文件中。
如果是需要加到仓库中的文件，通过 git add 可以将文件变为暂存状态，然后就可以提交到仓库中。
unmodified/未修改
存在仓库中的所有文件，如果本地文件未被修改，则是未修改的状态。
通过 git status 无法看到未修改的文件，但是可以看到哪些文件是属于已修改和暂存状态的。
modified/已修改
存在仓库中的文件，修改后，就会变成已修改状态，已修改的文件所在称为工作区。
通过 git add 可以将已修改的文件转成暂存状态，而 git checkout &amp;ndash; file 则将文件修改撤销，变为未修改状态。
staged/暂存
仓库文件转位暂存状态后，就是可以准备提交的状态了，暂存的文件所处暂存区。
通过 git commit 可以将所有暂存的文件提交，文件再次变为未修改状态，而 git reset HEAD file 则会将暂存的文件退回到已修改状态。
从上图中可以看到仓库文件的状态流转。不属于仓库的文件是 untracked 状态，属于仓库的文件是 unmodified 状态，作出更改后变为modified状态，将这些文件添加到暂存区就变成了 staged 状态，最后通过提交更新，将暂存区的文件提交到仓库，又变成了 unmodified 状态。
2. 配置 2.1 GitHub配置密钥 首先在本机创建SSH key，生成的key将会存在于~/.ssh/id_rsa.pub：
$ ssh-keygen -t rsa -C &amp;#34;email@example.com&amp;#34; 在GitHub打开setting，选择添加SSH Key，然后粘贴id_rsa.</description>
    </item>
    
    <item>
      <title>Go基础语法</title>
      <link>http://huanglianjing.com/posts/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 16 Jul 2023 18:17:33 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>1. 程序结构 1.1 名称 Go中函数、变量、常量、类型、语句标签、包的名称遵循规则：开头是一个字母或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。
对于语法中需要有变量名但程序逻辑用不到的，可以直接以一个下划线_表示空标识符。
关键字
Go有25个关键字，不能用于定义名称。
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 内置的预声明的常量、类型、函数
常量 true false itoa nil 类型 int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex64 complex128 bool byte rune string error 函数 make len cap new append copy close delete complex real imag panic recover 1.</description>
    </item>
    
  </channel>
</rss>
