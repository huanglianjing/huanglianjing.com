<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>pprof on huanglianjing</title>
    <link>http://huanglianjing.com/tags/pprof/</link>
    <description>Recent content in pprof on huanglianjing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 Jul 2023 01:52:12 +0800</lastBuildDate><atom:link href="http://huanglianjing.com/tags/pprof/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go Pprof性能分析</title>
      <link>http://huanglianjing.com/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 25 Jul 2023 01:52:12 +0800</pubDate>
      
      <guid>http://huanglianjing.com/posts/go-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>1. 简介 pprof 是 go 自带的一个对程序的性能进行可视化和分析的工具，它从 profile.proto 格式的采样数据集中读取数据，并生成可视化报告，帮助我们分析我们的程序性能，进而有所针对进行优化。
当服务在运行时，有时候会遇到内存占用越来越大、将机器的CPU占满、goroutine数量暴涨的情况，或者当我们准备针对已有的代码进行运行效率、内存占用等方面进行优化，这时候就是 pprof 可以派上用场的时候了。
pprof 的采集方式分为以下几种：
runtime/pprof：采集程序指定区块的运行数据，生成 profile.proto 文件并对其进行分析。 net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。 go test：通过运行测试用例，并指定所需标识来进行采集。 pprof 可以分析包含以下几种：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 Block Profiling：阻塞分析，记录协程阻塞等待同步的情况。 采集后支持通过生成报告、终端命令行、Web界面的形式进行分析。
2. 使用方式 2.1 net/http/pprof 端口监听 该方式适合于服务型应用，通过添加监听端口，采集 HTTP Server 运行时的数据进行分析。
代码示例：开启一个协程监听一个端口，然后对一个字符串不断地追加内容。
package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; &amp;#34;time&amp;#34; ) var datas []string func main() { go func() { _ = http.</description>
    </item>
    
  </channel>
</rss>
